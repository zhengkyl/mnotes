[{"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\index.js":"1","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\App.js":"2","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\reportWebVitals.js":"3","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\index.js":"4","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\exportMarkdown.js":"5","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\exportHtml.js":"6","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\keyboard.js":"7","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\mouseEvent.js":"8","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\event.js":"9","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\resize.js":"10","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\clipboard.js":"11","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\dragDrop.js":"12","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\clickEvent.js":"13","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\index.js":"14","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\index.js":"15","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\config\\index.js":"16","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\tooltip\\index.js":"17","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\getImageInfo.js":"18","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\domManipulate.js":"19","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\getLinkInfo.js":"20","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\selection\\dom.js":"21","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\dompurify.js":"22","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\enterCtrl.js":"23","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\backspaceCtrl.js":"24","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\core.js":"25","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\deleteCtrl.js":"26","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\history.js":"27","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tableDragBarCtrl.js":"28","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\copyCutCtrl.js":"29","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\arrowCtrl.js":"30","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tableBlockCtrl.js":"31","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tableSelectCellsCtrl.js":"32","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\paragraphCtrl.js":"33","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\updateCtrl.js":"34","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\searchCtrl.js":"35","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\pasteCtrl.js":"36","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\formatCtrl.js":"37","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tabCtrl.js":"38","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\containerCtrl.js":"39","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tocCtrl.js":"40","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\imageCtrl.js":"41","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\htmlBlock.js":"42","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\codeBlockCtrl.js":"43","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\inputCtrl.js":"44","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\emojiCtrl.js":"45","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\clickCtrl.js":"46","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\linkCtrl.js":"47","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\selection\\cursor.js":"48","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\footnoteCtrl.js":"49","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\importMarkdown.js":"50","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\dragDropCtrl.js":"51","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\selection\\index.js":"52","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\renderers\\index.js":"53","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\emojis\\index.js":"54","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\escapeCharacter.js":"55","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\index.js":"56","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\index.js":"57","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\index.js":"58","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\getParentCheckBox.js":"59","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\rules.js":"60","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\cumputeCheckBoxStatus.js":"61","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\turndownService.js":"62","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\sequence.js":"63","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\renderer.js":"64","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\parser.js":"65","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\options.js":"66","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\lexer.js":"67","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\prism\\index.js":"68","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\snabbdom.js":"69","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\utils.js":"70","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\utils.js":"71","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\slugger.js":"72","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\inlineLexer.js":"73","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\textRenderer.js":"74","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\prism\\loadLanguage.js":"75","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\blockRules.js":"76","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\index.js":"77","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\index.js":"78","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\urlify.js":"79","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\inlineRules.js":"80","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderContainerBlock.js":"81","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderBlock.js":"82","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderIcon.js":"83","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\footnoteIdentifier.js":"84","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderLeafBlock.js":"85","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\superSubScript.js":"86","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\referenceImage.js":"87","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\referenceLink.js":"88","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\multipleMath.js":"89","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\referenceDefinition.js":"90","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\strong.js":"91","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\em.js":"92","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\htmlEscape.js":"93","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\htmlRuby.js":"94","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\del.js":"95","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\emoji.js":"96","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\text.js":"97","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\delEmStringFactory.js":"98","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\inlineCode.js":"99","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\image.js":"100","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\loadImageAsync.js":"101","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\autoLinkExtension.js":"102","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\autoLink.js":"103","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\codeFense.js":"104","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\softLineBreak.js":"105","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\hr.js":"106","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\tailHeader.js":"107","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\inlineMath.js":"108","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\hardLineBreak.js":"109","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\link.js":"110","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\htmlTag.js":"111","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\header.js":"112","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\highlight.js":"113","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\backlash.js":"114","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\backlashInToken.js":"115","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderCopyButton.js":"116","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderTableDargBar.js":"117","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderContainerEditIcon.js":"118","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderToolBar.js":"119","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderFootnoteJump.js":"120","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\quickInsert\\index.js":"121","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\quickInsert\\config.js":"122","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\baseScrollFloat\\index.js":"123","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\baseFloat\\index.js":"124","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\tablePicker\\index.js":"125","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\Editor.js":"126"},{"size":503,"mtime":1610310634660,"results":"127","hashOfConfig":"128"},{"size":158,"mtime":1610310516616,"results":"129","hashOfConfig":"128"},{"size":362,"mtime":499162500000,"results":"130","hashOfConfig":"128"},{"size":13366,"mtime":1610148036890,"results":"131","hashOfConfig":"128"},{"size":13632,"mtime":1610148038206,"results":"132","hashOfConfig":"128"},{"size":11156,"mtime":1610148038175,"results":"133","hashOfConfig":"128"},{"size":9260,"mtime":1610148036846,"results":"134","hashOfConfig":"128"},{"size":2919,"mtime":1610148036859,"results":"135","hashOfConfig":"128"},{"size":2821,"mtime":1610148036823,"results":"136","hashOfConfig":"128"},{"size":694,"mtime":1610148036863,"results":"137","hashOfConfig":"128"},{"size":2323,"mtime":1610148036817,"results":"138","hashOfConfig":"128"},{"size":1207,"mtime":1610148036820,"results":"139","hashOfConfig":"128"},{"size":8655,"mtime":1610148036813,"results":"140","hashOfConfig":"128"},{"size":10480,"mtime":1610148038286,"results":"141","hashOfConfig":"128"},{"size":21825,"mtime":1610148036459,"results":"142","hashOfConfig":"128"},{"size":9641,"mtime":1610148036185,"results":"143","hashOfConfig":"128"},{"size":1650,"mtime":1610148038081,"results":"144","hashOfConfig":"128"},{"size":1003,"mtime":1610148038209,"results":"145","hashOfConfig":"128"},{"size":578,"mtime":1610148038125,"results":"146","hashOfConfig":"128"},{"size":497,"mtime":1610148038216,"results":"147","hashOfConfig":"128"},{"size":4884,"mtime":1610148037525,"results":"148","hashOfConfig":"128"},{"size":62,"mtime":1610148038139,"results":"149","hashOfConfig":"128"},{"size":17965,"mtime":1610148036371,"results":"150","hashOfConfig":"128"},{"size":17254,"mtime":1610148036225,"results":"151","hashOfConfig":"128"},{"size":2241,"mtime":1610148036316,"results":"152","hashOfConfig":"128"},{"size":2301,"mtime":1610148036319,"results":"153","hashOfConfig":"128"},{"size":1641,"mtime":1610148036410,"results":"154","hashOfConfig":"128"},{"size":10906,"mtime":1610148036714,"results":"155","hashOfConfig":"128"},{"size":10682,"mtime":1610148036309,"results":"156","hashOfConfig":"128"},{"size":6880,"mtime":1610148036191,"results":"157","hashOfConfig":"128"},{"size":13943,"mtime":1610148036681,"results":"158","hashOfConfig":"128"},{"size":8733,"mtime":1610148036747,"results":"159","hashOfConfig":"128"},{"size":33258,"mtime":1610148036563,"results":"160","hashOfConfig":"128"},{"size":19950,"mtime":1610148036787,"results":"161","hashOfConfig":"128"},{"size":3733,"mtime":1610148036608,"results":"162","hashOfConfig":"128"},{"size":17841,"mtime":1610148036604,"results":"163","hashOfConfig":"128"},{"size":10654,"mtime":1610148036406,"results":"164","hashOfConfig":"128"},{"size":13725,"mtime":1610148036640,"results":"165","hashOfConfig":"128"},{"size":3766,"mtime":1610148036276,"results":"166","hashOfConfig":"128"},{"size":606,"mtime":1610148036752,"results":"167","hashOfConfig":"128"},{"size":6483,"mtime":1610148036425,"results":"168","hashOfConfig":"128"},{"size":2025,"mtime":1610148036420,"results":"169","hashOfConfig":"128"},{"size":4908,"mtime":1610148036273,"results":"170","hashOfConfig":"128"},{"size":10725,"mtime":1610148036498,"results":"171","hashOfConfig":"128"},{"size":1218,"mtime":1610148036339,"results":"172","hashOfConfig":"128"},{"size":8324,"mtime":1610148036255,"results":"173","hashOfConfig":"128"},{"size":1045,"mtime":1610148036516,"results":"174","hashOfConfig":"128"},{"size":1337,"mtime":1610148037521,"results":"175","hashOfConfig":"128"},{"size":1965,"mtime":1610148036375,"results":"176","hashOfConfig":"128"},{"size":21286,"mtime":1610149345289,"results":"177","hashOfConfig":"128"},{"size":5797,"mtime":1610148036323,"results":"178","hashOfConfig":"128"},{"size":22383,"mtime":1610148037559,"results":"179","hashOfConfig":"128"},{"size":915,"mtime":1610148737962,"results":"180","hashOfConfig":"128"},{"size":1330,"mtime":1610148037674,"results":"181","hashOfConfig":"128"},{"size":5033,"mtime":1610148036896,"results":"182","hashOfConfig":"128"},{"size":937,"mtime":1610148036947,"results":"183","hashOfConfig":"128"},{"size":8146,"mtime":1610148037088,"results":"184","hashOfConfig":"128"},{"size":16058,"mtime":1610148036925,"results":"185","hashOfConfig":"128"},{"size":281,"mtime":1610148038219,"results":"186","hashOfConfig":"128"},{"size":2550,"mtime":1610148037456,"results":"187","hashOfConfig":"128"},{"size":337,"mtime":1610148038120,"results":"188","hashOfConfig":"128"},{"size":2001,"mtime":1610148038320,"results":"189","hashOfConfig":"128"},{"size":137,"mtime":1610148037448,"results":"190","hashOfConfig":"128"},{"size":6220,"mtime":1610148037040,"results":"191","hashOfConfig":"128"},{"size":5688,"mtime":1610148037023,"results":"192","hashOfConfig":"128"},{"size":968,"mtime":1610148037020,"results":"193","hashOfConfig":"128"},{"size":18247,"mtime":1610148037017,"results":"194","hashOfConfig":"128"},{"size":1101,"mtime":1610148037481,"results":"195","hashOfConfig":"128"},{"size":1111,"mtime":1610148037452,"results":"196","hashOfConfig":"128"},{"size":7954,"mtime":1610148037473,"results":"197","hashOfConfig":"128"},{"size":5156,"mtime":1610148037082,"results":"198","hashOfConfig":"128"},{"size":857,"mtime":1610148037046,"results":"199","hashOfConfig":"128"},{"size":11629,"mtime":1610148036980,"results":"200","hashOfConfig":"128"},{"size":1197,"mtime":1610148037050,"results":"201","hashOfConfig":"128"},{"size":3936,"mtime":1610148037501,"results":"202","hashOfConfig":"128"},{"size":6848,"mtime":1610148036941,"results":"203","hashOfConfig":"128"},{"size":1611,"mtime":1610148037318,"results":"204","hashOfConfig":"128"},{"size":275,"mtime":1610148037092,"results":"205","hashOfConfig":"128"},{"size":8398,"mtime":1610148037075,"results":"206","hashOfConfig":"128"},{"size":5272,"mtime":1610148036985,"results":"207","hashOfConfig":"128"},{"size":5989,"mtime":1610148037101,"results":"208","hashOfConfig":"128"},{"size":388,"mtime":1610148037097,"results":"209","hashOfConfig":"128"},{"size":3394,"mtime":1610148037125,"results":"210","hashOfConfig":"128"},{"size":863,"mtime":1610148037246,"results":"211","hashOfConfig":"128"},{"size":8484,"mtime":1610148037156,"results":"212","hashOfConfig":"128"},{"size":835,"mtime":1610148037418,"results":"213","hashOfConfig":"128"},{"size":1264,"mtime":1610148037371,"results":"214","hashOfConfig":"128"},{"size":2712,"mtime":1610148037387,"results":"215","hashOfConfig":"128"},{"size":311,"mtime":1610148037364,"results":"216","hashOfConfig":"128"},{"size":1780,"mtime":1610148037368,"results":"217","hashOfConfig":"128"},{"size":149,"mtime":1610148037403,"results":"218","hashOfConfig":"128"},{"size":141,"mtime":1610148037238,"results":"219","hashOfConfig":"128"},{"size":560,"mtime":1610148037273,"results":"220","hashOfConfig":"128"},{"size":994,"mtime":1610148037286,"results":"221","hashOfConfig":"128"},{"size":143,"mtime":1610148037226,"results":"222","hashOfConfig":"128"},{"size":1978,"mtime":1610148037241,"results":"223","hashOfConfig":"128"},{"size":222,"mtime":1610148037436,"results":"224","hashOfConfig":"128"},{"size":1110,"mtime":1610148037234,"results":"225","hashOfConfig":"128"},{"size":776,"mtime":1610148037330,"results":"226","hashOfConfig":"128"},{"size":4285,"mtime":1610148037306,"results":"227","hashOfConfig":"128"},{"size":2690,"mtime":1610148037351,"results":"228","hashOfConfig":"128"},{"size":641,"mtime":1610148037199,"results":"229","hashOfConfig":"128"},{"size":907,"mtime":1610148037187,"results":"230","hashOfConfig":"128"},{"size":531,"mtime":1610148037214,"results":"231","hashOfConfig":"128"},{"size":334,"mtime":1610148037399,"results":"232","hashOfConfig":"128"},{"size":301,"mtime":1610148037270,"results":"233","hashOfConfig":"128"},{"size":373,"mtime":1610148037421,"results":"234","hashOfConfig":"128"},{"size":1771,"mtime":1610148037342,"results":"235","hashOfConfig":"128"},{"size":545,"mtime":1610148037258,"results":"236","hashOfConfig":"128"},{"size":3932,"mtime":1610148037348,"results":"237","hashOfConfig":"128"},{"size":3218,"mtime":1610148037290,"results":"238","hashOfConfig":"128"},{"size":797,"mtime":1610148037263,"results":"239","hashOfConfig":"128"},{"size":897,"mtime":1610148037267,"results":"240","hashOfConfig":"128"},{"size":370,"mtime":1610148037203,"results":"241","hashOfConfig":"128"},{"size":865,"mtime":1610148037208,"results":"242","hashOfConfig":"128"},{"size":475,"mtime":1610148037118,"results":"243","hashOfConfig":"128"},{"size":290,"mtime":1610148037173,"results":"244","hashOfConfig":"128"},{"size":484,"mtime":1610148037114,"results":"245","hashOfConfig":"128"},{"size":1736,"mtime":1610148037176,"results":"246","hashOfConfig":"128"},{"size":122,"mtime":1610148037122,"results":"247","hashOfConfig":"128"},{"size":4143,"mtime":1610148037981,"results":"248","hashOfConfig":"128"},{"size":5016,"mtime":1610148037951,"results":"249","hashOfConfig":"128"},{"size":2279,"mtime":1610148037598,"results":"250","hashOfConfig":"128"},{"size":3811,"mtime":1610148037583,"results":"251","hashOfConfig":"128"},{"size":3834,"mtime":1610148038008,"results":"252","hashOfConfig":"128"},{"size":769,"mtime":1610339315244,"results":"253","hashOfConfig":"128"},{"filePath":"254","messages":"255","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},"1pnctam",{"filePath":"257","messages":"258","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"259","messages":"260","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"261","messages":"262","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"263","messages":"264","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"265","usedDeprecatedRules":"256"},{"filePath":"266","messages":"267","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"268","messages":"269","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"270","usedDeprecatedRules":"256"},{"filePath":"271","messages":"272","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"273","messages":"274","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"275","messages":"276","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"277","messages":"278","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"279","messages":"280","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"281","messages":"282","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"283","messages":"284","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"285","messages":"286","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"287","messages":"288","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"289","messages":"290","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"291","messages":"292","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"293","messages":"294","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"295","messages":"296","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"297","messages":"298","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"299","messages":"300","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"301","messages":"302","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"303","messages":"304","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"305","usedDeprecatedRules":"256"},{"filePath":"306","messages":"307","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"308","messages":"309","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"310","messages":"311","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"312","messages":"313","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"314","usedDeprecatedRules":"256"},{"filePath":"315","messages":"316","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"317","usedDeprecatedRules":"256"},{"filePath":"318","messages":"319","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"320","usedDeprecatedRules":"256"},{"filePath":"321","messages":"322","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"323","usedDeprecatedRules":"256"},{"filePath":"324","messages":"325","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"326","messages":"327","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"328","usedDeprecatedRules":"256"},{"filePath":"329","messages":"330","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"331","messages":"332","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"333","messages":"334","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"335","usedDeprecatedRules":"256"},{"filePath":"336","messages":"337","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"338","usedDeprecatedRules":"256"},{"filePath":"339","messages":"340","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"341","usedDeprecatedRules":"256"},{"filePath":"342","messages":"343","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"344","messages":"345","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"346","messages":"347","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"348","messages":"349","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"350","messages":"351","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"352","messages":"353","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"354","usedDeprecatedRules":"256"},{"filePath":"355","messages":"356","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"357","messages":"358","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"359","usedDeprecatedRules":"256"},{"filePath":"360","messages":"361","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"362","usedDeprecatedRules":"256"},{"filePath":"363","messages":"364","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"365","messages":"366","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"367","messages":"368","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"369","usedDeprecatedRules":"256"},{"filePath":"370","messages":"371","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"372","messages":"373","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"374","usedDeprecatedRules":"256"},{"filePath":"375","messages":"376","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"377","usedDeprecatedRules":"256"},{"filePath":"378","messages":"379","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"380","messages":"381","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"382","messages":"383","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"384","messages":"385","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"386","messages":"387","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"388","messages":"389","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"390","messages":"391","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"392","messages":"393","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"394","messages":"395","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"396","messages":"397","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"398"},{"filePath":"399","messages":"400","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"401","messages":"402","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"403","messages":"404","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"405","usedDeprecatedRules":"256"},{"filePath":"406","messages":"407","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"408","usedDeprecatedRules":"256"},{"filePath":"409","messages":"410","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"411","messages":"412","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"413","messages":"414","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"415","messages":"416","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"417","usedDeprecatedRules":"256"},{"filePath":"418","messages":"419","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"420","messages":"421","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"422","messages":"423","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"424","messages":"425","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"426","usedDeprecatedRules":"256"},{"filePath":"427","messages":"428","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"429","messages":"430","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"431","usedDeprecatedRules":"256"},{"filePath":"432","messages":"433","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"434","usedDeprecatedRules":"256"},{"filePath":"435","messages":"436","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"437","messages":"438","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"439","messages":"440","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"441","messages":"442","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"443","messages":"444","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"445","messages":"446","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"447","messages":"448","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"449","usedDeprecatedRules":"256"},{"filePath":"450","messages":"451","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"452","messages":"453","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"454","messages":"455","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"456","messages":"457","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"458","messages":"459","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"460","messages":"461","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"462","messages":"463","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"464","messages":"465","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"466","messages":"467","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"468","messages":"469","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"470","messages":"471","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"472","messages":"473","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"474","messages":"475","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"476","messages":"477","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"478","messages":"479","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"480","messages":"481","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"482","messages":"483","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"484","messages":"485","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"486","messages":"487","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"488","messages":"489","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"490","messages":"491","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"492","messages":"493","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"494","messages":"495","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"496","messages":"497","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"498","messages":"499","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"500","messages":"501","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"502","messages":"503","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"504","messages":"505","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"506","messages":"507","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"508","messages":"509","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"510","usedDeprecatedRules":"256"},{"filePath":"511","messages":"512","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"513","messages":"514","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"515","messages":"516","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"517","messages":"518","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"519","messages":"520","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"521","messages":"522","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"523","messages":"524","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"525","messages":"526","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"527","messages":"528","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"529","messages":"530","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"256"},{"filePath":"531","messages":"532","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\index.js",[],["533","534"],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\App.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\reportWebVitals.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\exportMarkdown.js",["535","536"],"/**\n * Hi contributors!\n *\n * Before you edit or update codes in this file,\n * make sure you have read this bellow:\n * Commonmark Spec: https://spec.commonmark.org/0.29/\n * GitHub Flavored Markdown Spec: https://github.github.com/gfm/\n * Pandoc Markdown: https://pandoc.org/MANUAL.html#pandocs-markdown\n * The output markdown needs to obey the standards of these Spec.\n */\n\nclass ExportMarkdown {\n  constructor (blocks, listIndentation = 1, isGitlabCompatibilityEnabled = false) {\n    this.blocks = blocks\n    this.listType = [] // 'ul' or 'ol'\n    // helper to translate the first tight item in a nested list\n    this.isLooseParentList = true\n    this.isGitlabCompatibilityEnabled = !!isGitlabCompatibilityEnabled\n\n    // set and validate settings\n    this.listIndentation = 'number'\n    if (listIndentation === 'dfm') {\n      this.listIndentation = 'dfm'\n      this.listIndentationCount = 4\n    } else if (typeof listIndentation === 'number') {\n      this.listIndentationCount = Math.min(Math.max(listIndentation, 1), 4)\n    } else {\n      this.listIndentationCount = 1\n    }\n  }\n\n  generate () {\n    return this.translateBlocks2Markdown(this.blocks)\n  }\n\n  translateBlocks2Markdown (blocks, indent = '', listIndent = '') {\n    const result = []\n    // helper for CommonMark 264\n    let lastListBullet = ''\n\n    for (const block of blocks) {\n      if (block.type !== 'ul' && block.type !== 'ol') {\n        lastListBullet = ''\n      }\n\n      switch (block.type) {\n        case 'p':\n        case 'hr': {\n          this.insertLineBreak(result, indent)\n          result.push(this.translateBlocks2Markdown(block.children, indent))\n          break\n        }\n        case 'span': {\n          result.push(this.normalizeParagraphText(block, indent))\n          break\n        }\n        case 'h1':\n        case 'h2':\n        case 'h3':\n        case 'h4':\n        case 'h5':\n        case 'h6': {\n          this.insertLineBreak(result, indent)\n          result.push(this.normalizeHeaderText(block, indent))\n          break\n        }\n        case 'figure': {\n          this.insertLineBreak(result, indent)\n          switch (block.functionType) {\n            case 'table': {\n              const table = block.children[0]\n              result.push(this.normalizeTable(table, indent))\n              break\n            }\n            case 'html': {\n              result.push(this.normalizeHTML(block, indent))\n              break\n            }\n            case 'footnote': {\n              result.push(this.normalizeFootnote(block, indent))\n              break\n            }\n            case 'multiplemath': {\n              result.push(this.normalizeMultipleMath(block, indent))\n              break\n            }\n            case 'mermaid':\n            case 'flowchart':\n            case 'sequence':\n            case 'vega-lite': {\n              result.push(this.normalizeContainer(block, indent))\n              break\n            }\n          }\n          break\n        }\n        case 'li': {\n          const insertNewLine = block.isLooseListItem\n\n          // helper variable to correct the first tight item in a nested list\n          this.isLooseParentList = insertNewLine\n          if (insertNewLine) {\n            this.insertLineBreak(result, indent)\n          }\n          result.push(this.normalizeListItem(block, indent + listIndent))\n          this.isLooseParentList = true\n          break\n        }\n        case 'ul': {\n          let insertNewLine = this.isLooseParentList\n          this.isLooseParentList = true\n\n          // Start a new list without separation due changing the bullet or ordered list delimiter starts a new list.\n          const { bulletMarkerOrDelimiter } = block.children[0]\n          if (lastListBullet && lastListBullet !== bulletMarkerOrDelimiter) {\n            insertNewLine = false\n          }\n          lastListBullet = bulletMarkerOrDelimiter\n          if (insertNewLine) {\n            this.insertLineBreak(result, indent)\n          }\n\n          this.listType.push({ type: 'ul' })\n          result.push(this.normalizeList(block, indent, listIndent))\n          this.listType.pop()\n          break\n        }\n        case 'ol': {\n          let insertNewLine = this.isLooseParentList\n          this.isLooseParentList = true\n\n          // Start a new list without separation due changing the bullet or ordered list delimiter starts a new list.\n          const { bulletMarkerOrDelimiter } = block.children[0]\n          if (lastListBullet && lastListBullet !== bulletMarkerOrDelimiter) {\n            insertNewLine = false\n          }\n          lastListBullet = bulletMarkerOrDelimiter\n          if (insertNewLine) {\n            this.insertLineBreak(result, indent)\n          }\n          const listCount = block.start !== undefined ? block.start : 1\n          this.listType.push({ type: 'ol', listCount })\n          result.push(this.normalizeList(block, indent, listIndent))\n          this.listType.pop()\n          break\n        }\n        case 'pre': {\n          this.insertLineBreak(result, indent)\n          if (block.functionType === 'frontmatter') {\n            result.push(this.normalizeFrontMatter(block, indent))\n          } else {\n            result.push(this.normalizeCodeBlock(block, indent))\n          }\n          break\n        }\n        case 'blockquote': {\n          this.insertLineBreak(result, indent)\n          result.push(this.normalizeBlockquote(block, indent))\n          break\n        }\n        default: {\n          console.warn('translateBlocks2Markdown: Unknown block type:', block.type)\n          break\n        }\n      }\n    }\n    return result.join('')\n  }\n\n  insertLineBreak (result, indent) {\n    if (!result.length) return\n    result.push(`${indent}\\n`)\n  }\n\n  normalizeParagraphText (block, indent) {\n    const { text } = block\n    const lines = text.split('\\n')\n    return lines.map(line => `${indent}${line}`).join('\\n') + '\\n'\n  }\n\n  normalizeHeaderText (block, indent) {\n    const { headingStyle, marker } = block\n    const { text } = block.children[0]\n    if (headingStyle === 'atx') {\n      const match = text.match(/(#{1,6})(.*)/)\n      const atxHeadingText = `${match[1]} ${match[2].trim()}`\n      return `${indent}${atxHeadingText}\\n`\n    } else if (headingStyle === 'setext') {\n      const lines = text.trim().split('\\n')\n      return lines.map(line => `${indent}${line}`).join('\\n') + `\\n${indent}${marker.trim()}\\n`\n    }\n  }\n\n  normalizeBlockquote (block, indent) {\n    const { children } = block\n    const newIndent = `${indent}> `\n    return this.translateBlocks2Markdown(children, newIndent)\n  }\n\n  normalizeFrontMatter (block, indent) { // preBlock\n    let startToken\n    let endToken\n    switch (block.lang) {\n      case 'yaml':\n        startToken = '---\\n'\n        endToken = '---\\n'\n        break\n      case 'toml':\n        startToken = '+++\\n'\n        endToken = '+++\\n'\n        break\n      case 'json':\n        if (block.style === ';') {\n          startToken = ';;;\\n'\n          endToken = ';;;\\n'\n        } else {\n          startToken = '{\\n'\n          endToken = '}\\n'\n        }\n        break\n    }\n\n    const result = []\n    result.push(startToken)\n    for (const line of block.children[0].children) {\n      result.push(`${line.text}\\n`)\n    }\n    result.push(endToken)\n    return result.join('')\n  }\n\n  normalizeMultipleMath (block, /* figure */ indent) {\n    const { isGitlabCompatibilityEnabled } = this\n    let startToken = '$$'\n    let endToken = '$$'\n    if (isGitlabCompatibilityEnabled && block.mathStyle === 'gitlab') {\n      startToken = '```math'\n      endToken = '```'\n    }\n\n    const result = []\n    result.push(`${indent}${startToken}\\n`)\n    for (const line of block.children[0].children[0].children) {\n      result.push(`${indent}${line.text}\\n`)\n    }\n    result.push(`${indent}${endToken}\\n`)\n    return result.join('')\n  }\n\n  // `mermaid` `flowchart` `sequence` `vega-lite`\n  normalizeContainer (block, indent) {\n    const result = []\n    const diagramType = block.children[0].functionType\n    result.push('```' + diagramType + '\\n')\n    for (const line of block.children[0].children[0].children) {\n      result.push(`${line.text}\\n`)\n    }\n    result.push('```\\n')\n    return result.join('')\n  }\n\n  normalizeCodeBlock (block, indent) {\n    const result = []\n    const codeContent = block.children[1].children[0]\n    const textList = codeContent.text.split('\\n')\n    const { functionType } = block\n    if (functionType === 'fencecode') {\n      result.push(`${indent}${block.lang ? '```' + block.lang + '\\n' : '```\\n'}`)\n      textList.forEach(text => {\n        result.push(`${indent}${text}\\n`)\n      })\n      result.push(indent + '```\\n')\n    } else {\n      textList.forEach(text => {\n        result.push(`${indent}    ${text}\\n`)\n      })\n    }\n\n    return result.join('')\n  }\n\n  normalizeHTML (block, indent) { // figure\n    const result = []\n    const codeContentText = block.children[0].children[0].children[0].text\n    const lines = codeContentText.split('\\n')\n    for (const line of lines) {\n      result.push(`${indent}${line}\\n`)\n    }\n    return result.join('')\n  }\n\n  normalizeTable (table, indent) {\n    const result = []\n    const { row, column } = table\n    const tableData = []\n    const tHeader = table.children[0]\n    const tBody = table.children[1]\n    const escapeText = str => {\n      return str.replace(/([^\\\\])\\|/g, '$1\\\\|')\n    }\n\n    tableData.push(tHeader.children[0].children.map(th => escapeText(th.children[0].text).trim()))\n    if (tBody) {\n      tBody.children.forEach(bodyRow => {\n        tableData.push(bodyRow.children.map(td => escapeText(td.children[0].text).trim()))\n      })\n    }\n\n    const columnWidth = tHeader.children[0].children.map(th => ({ width: 5, align: th.align }))\n\n    let i\n    let j\n\n    for (i = 0; i <= row; i++) {\n      for (j = 0; j <= column; j++) {\n        columnWidth[j].width = Math.max(columnWidth[j].width, tableData[i][j].length + 2) // add 2, because have two space around text\n      }\n    }\n    tableData.forEach((r, i) => {\n      const rs = indent + '|' + r.map((cell, j) => {\n        const raw = ` ${cell + ' '.repeat(columnWidth[j].width)}`\n        return raw.substring(0, columnWidth[j].width)\n      }).join('|') + '|'\n      result.push(rs)\n      if (i === 0) {\n        const cutOff = indent + '|' + columnWidth.map(({ width, align }) => {\n          let raw = '-'.repeat(width - 2)\n          switch (align) {\n            case 'left':\n              raw = `:${raw} `\n              break\n            case 'center':\n              raw = `:${raw}:`\n              break\n            case 'right':\n              raw = ` ${raw}:`\n              break\n            default:\n              raw = ` ${raw} `\n              break\n          }\n          return raw\n        }).join('|') + '|'\n        result.push(cutOff)\n      }\n    })\n    return result.join('\\n') + '\\n'\n  }\n\n  normalizeList (block, indent, listIndent) {\n    const { children } = block\n    return this.translateBlocks2Markdown(children, indent, listIndent)\n  }\n\n  normalizeListItem (block, indent) {\n    const result = []\n    const listInfo = this.listType[this.listType.length - 1]\n    const isUnorderedList = listInfo.type === 'ul'\n    let { children, bulletMarkerOrDelimiter } = block\n    let itemMarker\n\n    if (isUnorderedList) {\n      itemMarker = bulletMarkerOrDelimiter ? `${bulletMarkerOrDelimiter} ` : '- '\n    } else {\n      // NOTE: GitHub and Bitbucket limit the list count to 99 but this is nowhere defined.\n      //  We limit the number to 99 for Daring Fireball Markdown to prevent indentation issues.\n      let n = listInfo.listCount\n      if ((this.listIndentation === 'dfm' && n > 99) || n > 999999999) {\n        n = 1\n      }\n      listInfo.listCount++\n\n      const delimiter = bulletMarkerOrDelimiter || '.'\n      itemMarker = `${n}${delimiter} `\n    }\n\n    // Subsequent paragraph indentation\n    const newIndent = indent + ' '.repeat(itemMarker.length)\n\n    // New list indentation. We already added one space to the indentation\n    let listIndent = ''\n    const { listIndentation } = this\n    if (listIndentation === 'dfm') {\n      listIndent = ' '.repeat(4 - itemMarker.length)\n    } else if (listIndentation === 'number') {\n      listIndent = ' '.repeat(this.listIndentationCount - 1)\n    }\n\n    // TODO: Indent subsequent paragraphs by one tab. - not important\n    //  Problem: \"translateBlocks2Markdown\" use \"indent\" in spaces to indent elements. How should\n    //  we integrate tabs in blockquotes and subsequent paragraphs and how to combine with spaces?\n    //  I don't know how to combine tabs and spaces and it seems not specified, so work for another day.\n\n    if (isUnorderedList && block.listItemType === 'task') {\n      const firstChild = children[0]\n      itemMarker += firstChild.checked ? '[x] ' : '[ ] '\n      children = children.slice(1)\n    }\n\n    result.push(`${indent}${itemMarker}`)\n    result.push(this.translateBlocks2Markdown(children, newIndent, listIndent).substring(newIndent.length))\n    return result.join('')\n  }\n\n  normalizeFootnote (block, indent) {\n    const result = []\n    const identifier = block.children[0].text\n    result.push(`${indent}[^${identifier}]:`)\n    const hasMultipleBlocks = block.children.length > 2 || block.children[1].type !== 'p'\n    if (hasMultipleBlocks) {\n      result.push('\\n')\n      const newIndent = indent + ' '.repeat(4)\n      result.push(this.translateBlocks2Markdown(block.children.slice(1), newIndent))\n    } else {\n      result.push(' ')\n      const paragraphContent = block.children[1].children[0]\n      result.push(this.normalizeParagraphText(paragraphContent, indent))\n    }\n\n    return result.join('')\n  }\n}\n\nexport default ExportMarkdown\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\exportHtml.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\keyboard.js",["537"],"import { EVENT_KEYS } from '../config'\nimport selection from '../selection'\nimport { findNearestParagraph } from '../selection/dom'\nimport { getParagraphReference, getImageInfo } from '../utils'\nimport { checkEditEmoji } from '../ui/emojis'\n\nclass Keyboard {\n  constructor (muya) {\n    this.muya = muya\n    this.isComposed = false\n    this.shownFloat = new Set()\n    this.recordIsComposed()\n    this.dispatchEditorState()\n    this.keydownBinding()\n    this.keyupBinding()\n    this.inputBinding()\n    this.listen()\n  }\n\n  listen () {\n    // cache shown float box\n    this.muya.eventCenter.subscribe('muya-float', (tool, status) => {\n      status ? this.shownFloat.add(tool) : this.shownFloat.delete(tool)\n      if (tool.name === 'ag-front-menu' && !status) {\n        const seletedParagraph = this.muya.container.querySelector('.ag-selected')\n        if (seletedParagraph) {\n          this.muya.contentState.selectedBlock = null\n          // prevent rerender, so change the class manually.\n          seletedParagraph.classList.toggle('ag-selected')\n        }\n      }\n    })\n  }\n\n  hideAllFloatTools () {\n    for (const tool of this.shownFloat) {\n      tool.hide()\n    }\n  }\n\n  recordIsComposed () {\n    const { container, eventCenter, contentState } = this.muya\n    const handler = event => {\n      if (event.type === 'compositionstart') {\n        this.isComposed = true\n      } else if (event.type === 'compositionend') {\n        this.isComposed = false\n        // Because the compose event will not cause `input` event, So need call `inputHandler` by ourself\n        contentState.inputHandler(event)\n        eventCenter.dispatch('stateChange')\n      }\n    }\n\n    eventCenter.attachDOMEvent(container, 'compositionend', handler)\n    // eventCenter.attachDOMEvent(container, 'compositionupdate', handler)\n    eventCenter.attachDOMEvent(container, 'compositionstart', handler)\n  }\n\n  dispatchEditorState () {\n    const { container, eventCenter } = this.muya\n\n    let timer = null\n    const changeHandler = event => {\n      if (\n        event.type === 'keyup' &&\n        (event.key === EVENT_KEYS.ArrowUp || event.key === EVENT_KEYS.ArrowDown) &&\n        this.shownFloat.size > 0\n      ) {\n        return\n      }\n      // Cursor outside editor area or over not editable elements.\n      if (event.target.closest('[contenteditable=false]')) {\n        return\n      }\n\n      // We need check cursor is null, because we may copy the html preview content,\n      // and no need to dispatch change.\n      const { start, end } = selection.getCursorRange()\n      if (!start || !end) {\n        return\n      }\n\n      if (timer) clearTimeout(timer)\n      timer = setTimeout(() => {\n        this.muya.dispatchSelectionChange()\n        this.muya.dispatchSelectionFormats()\n        if (!this.isComposed && event.type === 'click') {\n          this.muya.dispatchChange()\n        }\n      })\n    }\n\n    eventCenter.attachDOMEvent(container, 'click', changeHandler)\n    eventCenter.attachDOMEvent(container, 'keyup', changeHandler)\n  }\n\n  keydownBinding () {\n    const { container, eventCenter, contentState } = this.muya\n    const docHandler = event => {\n      switch (event.code) {\n        case EVENT_KEYS.Enter:\n          return contentState.docEnterHandler(event)\n        case EVENT_KEYS.Space: {\n          if (contentState.selectedImage) {\n            const { token } = contentState.selectedImage\n            const { src } = getImageInfo(token.src || token.attrs.src)\n            if (src) {\n              eventCenter.dispatch('preview-image', {\n                data: src\n              })\n            }\n          }\n          break\n        }\n        case EVENT_KEYS.Backspace: {\n          return contentState.docBackspaceHandler(event)\n        }\n        case EVENT_KEYS.Delete: {\n          return contentState.docDeleteHandler(event)\n        }\n        case EVENT_KEYS.ArrowUp: // fallthrough\n        case EVENT_KEYS.ArrowDown: // fallthrough\n        case EVENT_KEYS.ArrowLeft: // fallthrough\n        case EVENT_KEYS.ArrowRight: // fallthrough\n          return contentState.docArrowHandler(event)\n      }\n    }\n\n    const handler = event => {\n      if (event.metaKey || event.ctrlKey) {\n        container.classList.add('ag-meta-or-ctrl')\n      }\n\n      if (\n        this.shownFloat.size > 0 &&\n        (\n          event.key === EVENT_KEYS.Enter ||\n          event.key === EVENT_KEYS.Escape ||\n          event.key === EVENT_KEYS.Tab ||\n          event.key === EVENT_KEYS.ArrowUp ||\n          event.key === EVENT_KEYS.ArrowDown\n        )\n      ) {\n        let needPreventDefault = false\n\n        for (const tool of this.shownFloat) {\n          if (\n            tool.name === 'ag-format-picker' ||\n            tool.name === 'ag-table-picker' ||\n            tool.name === 'ag-quick-insert' ||\n            tool.name === 'ag-emoji-picker' ||\n            tool.name === 'ag-front-menu' ||\n            tool.name === 'ag-list-picker' ||\n            tool.name === 'ag-image-selector'\n          ) {\n            needPreventDefault = true\n            break\n          }\n        }\n        if (needPreventDefault) {\n          event.preventDefault()\n        }\n        // event.stopPropagation()\n        return\n      }\n      switch (event.key) {\n        case EVENT_KEYS.Backspace:\n          contentState.backspaceHandler(event)\n          break\n        case EVENT_KEYS.Delete:\n          contentState.deleteHandler(event)\n          break\n        case EVENT_KEYS.Enter:\n          if (!this.isComposed) {\n            contentState.enterHandler(event)\n            this.muya.dispatchChange()\n          }\n          break\n        case EVENT_KEYS.ArrowUp: // fallthrough\n        case EVENT_KEYS.ArrowDown: // fallthrough\n        case EVENT_KEYS.ArrowLeft: // fallthrough\n        case EVENT_KEYS.ArrowRight: // fallthrough\n          if (!this.isComposed) {\n            contentState.arrowHandler(event)\n          }\n          break\n        case EVENT_KEYS.Tab:\n          contentState.tabHandler(event)\n          break\n        default:\n          break\n      }\n    }\n\n    eventCenter.attachDOMEvent(container, 'keydown', handler)\n    eventCenter.attachDOMEvent(document, 'keydown', docHandler)\n  }\n\n  inputBinding () {\n    const { container, eventCenter, contentState } = this.muya\n    const inputHandler = event => {\n      if (!this.isComposed) {\n        contentState.inputHandler(event)\n        this.muya.dispatchChange()\n      }\n\n      const { lang, paragraph } = contentState.checkEditLanguage()\n      if (lang) {\n        eventCenter.dispatch('muya-code-picker', {\n          reference: getParagraphReference(paragraph, paragraph.id),\n          lang,\n          cb: item => {\n            contentState.selectLanguage(paragraph, item.name)\n          }\n        })\n      } else {\n        // hide code picker float box\n        eventCenter.dispatch('muya-code-picker', { reference: null })\n      }\n    }\n\n    eventCenter.attachDOMEvent(container, 'input', inputHandler)\n  }\n\n  keyupBinding () {\n    const { container, eventCenter, contentState } = this.muya\n    const handler = event => {\n      container.classList.remove('ag-meta-or-ctrl')\n      // check if edit emoji\n      const node = selection.getSelectionStart()\n      const paragraph = findNearestParagraph(node)\n      const emojiNode = checkEditEmoji(node)\n      contentState.selectedImage = null\n      if (\n        paragraph &&\n        emojiNode &&\n        event.key !== EVENT_KEYS.Enter &&\n        event.key !== EVENT_KEYS.ArrowDown &&\n        event.key !== EVENT_KEYS.ArrowUp &&\n        event.key !== EVENT_KEYS.Tab &&\n        event.key !== EVENT_KEYS.Escape\n      ) {\n        const reference = getParagraphReference(emojiNode, paragraph.id)\n        eventCenter.dispatch('muya-emoji-picker', {\n          reference,\n          emojiNode\n        })\n      }\n      if (!emojiNode) {\n        eventCenter.dispatch('muya-emoji-picker', {\n          emojiNode\n        })\n      }\n\n      const { anchor, focus, start, end } = selection.getCursorRange()\n      if (!anchor || !focus) {\n        return\n      }\n      if (\n        !this.isComposed\n      ) {\n        const { anchor: oldAnchor, focus: oldFocus } = contentState.cursor\n        if (\n          anchor.key !== oldAnchor.key ||\n          anchor.offset !== oldAnchor.offset ||\n          focus.key !== oldFocus.key ||\n          focus.offset !== oldFocus.offset\n        ) {\n          const needRender = contentState.checkNeedRender(contentState.cursor) || contentState.checkNeedRender({ start, end })\n          contentState.cursor = { anchor, focus }\n          if (needRender) {\n            return contentState.partialRender()\n          }\n        }\n      }\n\n      const block = contentState.getBlock(anchor.key)\n      if (\n        anchor.key === focus.key &&\n        anchor.offset !== focus.offset &&\n        block.functionType !== 'codeContent' &&\n        block.functionType !== 'languageInput'\n      ) {\n        const reference = contentState.getPositionReference()\n        const { formats } = contentState.selectionFormats()\n        eventCenter.dispatch('muya-format-picker', { reference, formats })\n      } else {\n        eventCenter.dispatch('muya-format-picker', { reference: null })\n      }\n    }\n\n    eventCenter.attachDOMEvent(container, 'keyup', handler) // temp use input event\n  }\n}\n\nexport default Keyboard\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\mouseEvent.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\event.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\resize.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\clipboard.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\dragDrop.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\eventHandler\\clickEvent.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\config\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\tooltip\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\getImageInfo.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\domManipulate.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\getLinkInfo.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\selection\\dom.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\dompurify.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\enterCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\backspaceCtrl.js",["538","539","540","541","542","543","544","545"],"import selection from '../selection'\nimport { findNearestParagraph, findOutMostParagraph } from '../selection/dom'\nimport { tokenizer, generator } from '../parser/'\nimport { getImageInfo } from '../utils/getImageInfo'\n\nconst backspaceCtrl = ContentState => {\n  ContentState.prototype.checkBackspaceCase = function () {\n    const node = selection.getSelectionStart()\n    const paragraph = findNearestParagraph(node)\n    const outMostParagraph = findOutMostParagraph(node)\n    let block = this.getBlock(paragraph.id)\n    if (block.type === 'span' && block.preSibling) {\n      return false\n    }\n    if (block.type === 'span') {\n      block = this.getParent(block)\n    }\n    const preBlock = this.getPreSibling(block)\n    const outBlock = this.findOutMostBlock(block)\n    const parent = this.getParent(block)\n\n    const { left: outLeft } = selection.getCaretOffsets(outMostParagraph)\n    const { left: inLeft } = selection.getCaretOffsets(paragraph)\n\n    if (\n      (parent && parent.type === 'li' && inLeft === 0 && this.isFirstChild(block)) ||\n      (parent && parent.type === 'li' && inLeft === 0 && parent.listItemType === 'task' && preBlock.type === 'input') // handle task item\n    ) {\n      if (this.isOnlyChild(parent)) {\n        /**\n         * <ul>\n         *   <li>\n         *     <p>|text</p>\n         *     <p>maybe has other paragraph</p>\n         *   </li>\n         * <ul>\n         * ===>\n         * <p>|text</p>\n         * <p>maybe has other paragraph</p>\n         */\n        return { type: 'LI', info: 'REPLACEMENT' }\n      } else if (this.isFirstChild(parent)) {\n        /**\n         * <ul>\n         *   <li>\n         *     <p>|text</p>\n         *     <p>maybe has other paragraph</p>\n         *   </li>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         * <ul>\n         * ===>\n         * <p>|text</p>\n         * <p>maybe has other paragraph</p>\n         * <ul>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         * <ul>\n         */\n        return { type: 'LI', info: 'REMOVE_INSERT_BEFORE' }\n      } else {\n        /**\n         * <ul>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         *   <li>\n         *     <p>|text</p>\n         *     <p>maybe has other paragraph</p>\n         *   </li>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         * <ul>\n         * ===>\n         * <ul>\n         *   <li>\n         *     <p>other list item</p>\n         *     <p>|text</p>\n         *     <p>maybe has other paragraph</p>\n         *   </li>\n         *   <li>\n         *     <p>other list item</p>\n         *   </li>\n         * <ul>\n         */\n        return { type: 'LI', info: 'INSERT_PRE_LIST_ITEM' }\n      }\n    }\n    if (parent && parent.type === 'blockquote' && inLeft === 0) {\n      if (this.isOnlyChild(block)) {\n        return { type: 'BLOCKQUOTE', info: 'REPLACEMENT' }\n      } else if (this.isFirstChild(block)) {\n        return { type: 'BLOCKQUOTE', info: 'INSERT_BEFORE' }\n      }\n    }\n    if (!outBlock.preSibling && outLeft === 0) {\n      return { type: 'STOP' }\n    }\n  }\n\n  ContentState.prototype.docBackspaceHandler = function (event) {\n    // handle delete selected image\n    if (this.selectedImage) {\n      event.preventDefault()\n      return this.deleteImage(this.selectedImage)\n    }\n    if (this.selectedTableCells) {\n      event.preventDefault()\n      return this.deleteSelectedTableCells()\n    }\n  }\n\n  ContentState.prototype.backspaceHandler = function (event) {\n    const { start, end } = selection.getCursorRange()\n\n    if (!start || !end) {\n      return\n    }\n\n    // handle delete selected image\n    if (this.selectedImage) {\n      event.preventDefault()\n      return this.deleteImage(this.selectedImage)\n    }\n\n    // Handle select all content.\n    if (this.isSelectAll()) {\n      event.preventDefault()\n      this.blocks = [this.createBlockP()]\n      this.init()\n\n      this.render()\n\n      this.muya.dispatchSelectionChange()\n      this.muya.dispatchSelectionFormats()\n      return this.muya.dispatchChange()\n    }\n\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const maybeLastRow = this.getParent(endBlock)\n    const startOutmostBlock = this.findOutMostBlock(startBlock)\n    const endOutmostBlock = this.findOutMostBlock(endBlock)\n    // Just for fix delete the last `#` or all the atx heading cause error @fixme\n    if (\n      start.key === end.key &&\n      startBlock.type === 'span' &&\n      startBlock.functionType === 'atxLine'\n    ) {\n      if (\n        start.offset === 0 && end.offset === startBlock.text.length ||\n        start.offset === end.offset && start.offset === 1 && startBlock.text === '#'\n      ) {\n        event.preventDefault()\n        startBlock.text = ''\n        this.cursor = {\n          start: { key: start.key, offset: 0 },\n          end: { key: end.key, offset: 0 }\n        }\n        this.updateToParagraph(this.getParent(startBlock), startBlock)\n        return this.partialRender()\n      }\n    }\n    // fix: #897\n    const { text } = startBlock\n    const tokens = tokenizer(text, {\n      options: this.muya.options\n    })\n    let needRender = false\n    let preToken = null\n    for (const token of tokens) {\n      // handle delete the second $ in inline_math.\n      if (\n        token.range.end === start.offset &&\n        token.type === 'inline_math'\n      ) {\n        needRender = true\n        token.raw = token.raw.substr(0, token.raw.length - 1)\n        break\n      }\n      // handle pre token is a <ruby> html tag, need preventdefault.\n      if (\n        token.range.start + 1 === start.offset &&\n        preToken &&\n        preToken.type === 'html_tag' &&\n        preToken.tag === 'ruby'\n      ) {\n        needRender = true\n        token.raw = token.raw.substr(1)\n        break\n      }\n      preToken = token\n    }\n    if (needRender) {\n      startBlock.text = generator(tokens)\n      event.preventDefault()\n      start.offset--\n      end.offset--\n      this.cursor = {\n        start,\n        end\n      }\n      return this.partialRender()\n    }\n\n    // fix bug when the first block is table, these two ways will cause bugs.\n    // 1. one paragraph bollow table, selectAll, press backspace.\n    // 2. select table from the first cell to the last cell, press backsapce.\n    const maybeCell = this.getParent(startBlock)\n    if (/th/.test(maybeCell.type) && start.offset === 0 && !maybeCell.preSibling) {\n      if (\n        end.offset === endBlock.text.length &&\n        startOutmostBlock === endOutmostBlock &&\n        !endBlock.nextSibling && !maybeLastRow.nextSibling ||\n        startOutmostBlock !== endOutmostBlock\n      ) {\n        event.preventDefault()\n        // need remove the figure block.\n        const figureBlock = this.getBlock(this.closest(startBlock, 'figure'))\n        // if table is the only block, need create a p block.\n        const p = this.createBlockP(endBlock.text.substring(end.offset))\n        this.insertBefore(p, figureBlock)\n        const cursorBlock = p.children[0]\n        if (startOutmostBlock !== endOutmostBlock) {\n          this.removeBlocks(figureBlock, endBlock)\n        }\n\n        this.removeBlock(figureBlock)\n        const { key } = cursorBlock\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        return this.render()\n      }\n    }\n\n    // Fixed #1456 existed bugs `Select one cell and press backspace will cause bug`\n    if (startBlock.functionType === 'cellContent' && this.cursor.start.offset === 0 && this.cursor.end.offset !== 0 && this.cursor.end.offset === startBlock.text.length) {\n      event.preventDefault()\n      event.stopPropagation()\n      startBlock.text = ''\n      const { key } = startBlock\n      const offset = 0\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.singleRender(startBlock)\n    }\n\n    // If select multiple paragraph or multiple characters in one paragraph, just let\n    // inputCtrl to handle this case.\n    if (start.key !== end.key || start.offset !== end.offset) {\n      return\n    }\n\n    const node = selection.getSelectionStart()\n    const parentNode = node && node.nodeType === 1 ? node.parentNode : null\n    const paragraph = findNearestParagraph(node)\n    const id = paragraph.id\n    let block = this.getBlock(id)\n    let parent = this.getBlock(block.parent)\n    const preBlock = this.findPreBlockInLocation(block)\n    const { left, right } = selection.getCaretOffsets(paragraph)\n    const inlineDegrade = this.checkBackspaceCase()\n    // Handle backspace when the previous is an inline image.\n    if (parentNode && parentNode.classList.contains('ag-inline-image')) {\n      if (selection.getCaretOffsets(node).left === 0) {\n        event.preventDefault()\n        event.stopPropagation()\n        const imageInfo = getImageInfo(parentNode)\n        return this.deleteImage(imageInfo)\n      }\n      if (selection.getCaretOffsets(node).left === 1 && right === 0) {\n        event.stopPropagation()\n        event.preventDefault()\n        const key = startBlock.key\n        const text = startBlock.text\n\n        startBlock.text = text.substring(0, start.offset - 1) + text.substring(start.offset)\n        const offset = start.offset - 1\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        return this.singleRender(startBlock)\n      }\n    }\n\n    // handle backspace when cursor at the end of inline image.\n    if (node.classList.contains('ag-image-container')) {\n      const imageWrapper = node.parentNode\n      const imageInfo = getImageInfo(imageWrapper)\n      if (start.offset === imageInfo.token.range.end) {\n        event.preventDefault()\n        event.stopPropagation()\n        return this.selectImage(imageInfo)\n      }\n    }\n\n    // Fix issue #1218\n    if (startBlock.functionType === 'cellContent' && /<br\\/>.{1}$/.test(startBlock.text)) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      const { text } = startBlock\n      startBlock.text = text.substring(0, text.length - 1)\n      const key = startBlock.key\n      const offset = startBlock.text.length\n\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      return this.singleRender(startBlock)\n    }\n\n    // Fix delete the last character in table cell, the default action will delete the cell content if not preventDefault.\n    if (startBlock.functionType === 'cellContent' && left === 1 && right === 0) {\n      event.stopPropagation()\n      event.preventDefault()\n      startBlock.text = ''\n      const { key } = startBlock\n      const offset = 0\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.singleRender(startBlock)\n    }\n\n    const tableHasContent = table => {\n      const tHead = table.children[0]\n      const tBody = table.children[1]\n      const tHeadHasContent = tHead.children[0].children.some(th => th.children[0].text.trim())\n      const tBodyHasContent = tBody.children.some(row => row.children.some(td => td.children[0].text.trim()))\n      return tHeadHasContent || tBodyHasContent\n    }\n\n    if (\n      block.type === 'span' &&\n      block.functionType === 'paragraphContent' &&\n      left === 0 &&\n      preBlock &&\n      preBlock.functionType === 'footnoteInput'\n    ) {\n      event.preventDefault()\n      event.stopPropagation()\n      if (!parent.nextSibling) {\n        const pBlock = this.createBlockP(block.text)\n        const figureBlock = this.closest(block, 'figure')\n        this.insertBefore(pBlock, figureBlock)\n        this.removeBlock(figureBlock)\n        const key = pBlock.children[0].key\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n\n        this.partialRender()\n      }\n    } else if (\n      block.type === 'span' &&\n      block.functionType === 'codeContent' &&\n      left === 0 &&\n      !block.preSibling\n    ) {\n      event.preventDefault()\n      event.stopPropagation()\n      if (\n        !block.nextSibling\n      ) {\n        const preBlock = this.getParent(parent)\n        const pBlock = this.createBlock('p')\n        const lineBlock = this.createBlock('span', { text: block.text })\n        const key = lineBlock.key\n        const offset = 0\n        this.appendChild(pBlock, lineBlock)\n        let referenceBlock = null\n        switch (preBlock.functionType) {\n          case 'fencecode':\n          case 'indentcode':\n          case 'frontmatter':\n            referenceBlock = preBlock\n            break\n          case 'multiplemath':\n          case 'flowchart':\n          case 'mermaid':\n          case 'sequence':\n          case 'vega-lite':\n          case 'html':\n            referenceBlock = this.getParent(preBlock)\n            break\n        }\n        this.insertBefore(pBlock, referenceBlock)\n        this.removeBlock(referenceBlock)\n\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        this.partialRender()\n      }\n    } else if (left === 0 && block.functionType === 'cellContent') {\n      event.preventDefault()\n      event.stopPropagation()\n      const table = this.closest(block, 'table')\n      const figure = this.closest(table, 'figure')\n      const hasContent = tableHasContent(table)\n      let key\n      let offset\n\n      if ((!preBlock || preBlock.functionType !== 'cellContent') && !hasContent) {\n        const paragraphContent = this.createBlock('span')\n        delete figure.functionType\n        figure.children = []\n        this.appendChild(figure, paragraphContent)\n        figure.text = ''\n        figure.type = 'p'\n        key = paragraphContent.key\n        offset = 0\n      } else if (preBlock) {\n        key = preBlock.key\n        offset = preBlock.text.length\n      }\n\n      if (key !== undefined && offset !== undefined) {\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n\n        this.partialRender()\n      }\n    } else if (inlineDegrade) {\n      event.preventDefault()\n      if (block.type === 'span') {\n        block = this.getParent(block)\n        parent = this.getParent(parent)\n      }\n\n      switch (inlineDegrade.type) {\n        case 'STOP': // Cursor at begin of article and nothing need to do\n          break\n        case 'LI': {\n          if (inlineDegrade.info === 'REPLACEMENT') {\n            const children = parent.children\n            const grandpa = this.getBlock(parent.parent)\n            if (children[0].type === 'input') {\n              this.removeBlock(children[0])\n            }\n            children.forEach(child => {\n              this.insertBefore(child, grandpa)\n            })\n            this.removeBlock(grandpa)\n          } else if (inlineDegrade.info === 'REMOVE_INSERT_BEFORE') {\n            const children = parent.children\n            const grandpa = this.getBlock(parent.parent)\n            if (children[0].type === 'input') {\n              this.removeBlock(children[0])\n            }\n            children.forEach(child => {\n              this.insertBefore(child, grandpa)\n            })\n            this.removeBlock(parent)\n          } else if (inlineDegrade.info === 'INSERT_PRE_LIST_ITEM') {\n            const parPre = this.getBlock(parent.preSibling)\n            const children = parent.children\n            if (children[0].type === 'input') {\n              this.removeBlock(children[0])\n            }\n            children.forEach(child => {\n              this.appendChild(parPre, child)\n            })\n            this.removeBlock(parent)\n          }\n          break\n        }\n        case 'BLOCKQUOTE':\n          if (inlineDegrade.info === 'REPLACEMENT') {\n            this.insertBefore(block, parent)\n            this.removeBlock(parent)\n          } else if (inlineDegrade.info === 'INSERT_BEFORE') {\n            this.removeBlock(block)\n            this.insertBefore(block, parent)\n          }\n          break\n      }\n\n      const key = block.type === 'p' ? block.children[0].key : block.key\n      const offset = 0\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      if (inlineDegrade.type !== 'STOP') {\n        this.partialRender()\n      }\n    } else if (left === 0 && preBlock) {\n      event.preventDefault()\n      const { text } = block\n      const key = preBlock.key\n      const offset = preBlock.text.length\n      preBlock.text += text\n      // If block is a line block and its parent paragraph only has one text line,\n      // also need to remove the paragrah\n      if (this.isOnlyChild(block) && block.type === 'span') {\n        this.removeBlock(parent)\n      } else if (block.functionType !== 'languageInput' && block.functionType !== 'footnoteInput') {\n        this.removeBlock(block)\n      }\n\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      let needRenderAll = false\n\n      if (this.isCollapse() && preBlock.type === 'span' && preBlock.functionType === 'paragraphContent') {\n        this.checkInlineUpdate(preBlock)\n        needRenderAll = true\n      }\n\n      needRenderAll ? this.render() : this.partialRender()\n    }\n  }\n}\n\nexport default backspaceCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\core.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\deleteCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\history.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tableDragBarCtrl.js",["546","547"],"const calculateAspects = (tableId, barType) => {\n  const table = document.querySelector(`#${tableId}`)\n  if (barType === 'bottom') {\n    const firstRow = table.querySelector('tr')\n    return Array.from(firstRow.children).map(cell => cell.clientWidth)\n  } else {\n    return Array.from(table.querySelectorAll('tr')).map(row => row.clientHeight)\n  }\n}\n\nexport const getAllTableCells = tableId => {\n  const table = document.querySelector(`#${tableId}`)\n  const rows = table.querySelectorAll('tr')\n  const cells = []\n  for (const row of Array.from(rows)) {\n    cells.push(Array.from(row.children))\n  }\n\n  return cells\n}\n\nexport const getIndex = (barType, cell) => {\n  if (cell.tagName === 'SPAN') {\n    cell = cell.parentNode\n  }\n  const row = cell.parentNode\n  if (barType === 'bottom') {\n    return Array.from(row.children).indexOf(cell)\n  } else {\n    const rowContainer = row.parentNode\n    if (rowContainer.tagName === 'THEAD') {\n      return 0\n    } else {\n      return Array.from(rowContainer.children).indexOf(row) + 1\n    }\n  }\n}\n\nconst getDragCells = (tableId, barType, index) => {\n  const table = document.querySelector(`#${tableId}`)\n  const dragCells = []\n  if (barType === 'left') {\n    if (index === 0) {\n      dragCells.push(...table.querySelectorAll('th'))\n    } else {\n      const row = table.querySelector('tbody').children[index - 1]\n      dragCells.push(...row.children)\n    }\n  } else {\n    const rows = Array.from(table.querySelectorAll('tr'))\n    const len = rows.length\n    let i\n    for (i = 0; i < len; i++) {\n      dragCells.push(rows[i].children[index])\n    }\n  }\n  return dragCells\n}\n\nconst tableDragBarCtrl = ContentState => {\n  ContentState.prototype.handleMouseDown = function (event) {\n    event.preventDefault()\n    const { eventCenter } = this.muya\n    const { clientX, clientY, target } = event\n    const tableId = target.closest('table').id\n    const barType = target.classList.contains('left') ? 'left' : 'bottom'\n    const index = getIndex(barType, target)\n    const aspects = calculateAspects(tableId, barType)\n    this.dragInfo = {\n      tableId,\n      clientX,\n      clientY,\n      barType,\n      index,\n      curIndex: index,\n      dragCells: getDragCells(tableId, barType, index),\n      cells: getAllTableCells(tableId),\n      aspects,\n      offset: 0\n    }\n\n    for (const row of this.dragInfo.cells) {\n      for (const cell of row) {\n        if (!this.dragInfo.dragCells.includes(cell)) {\n          cell.classList.add('ag-cell-transform')\n        }\n      }\n    }\n\n    const mouseMoveId = eventCenter.attachDOMEvent(document, 'mousemove', this.handleMouseMove.bind(this))\n    const mouseUpId = eventCenter.attachDOMEvent(document, 'mouseup', this.handleMouseUp.bind(this))\n    this.dragEventIds.push(mouseMoveId, mouseUpId)\n  }\n\n  ContentState.prototype.handleMouseMove = function (event) {\n    if (!this.dragInfo) {\n      return\n    }\n    const { barType } = this.dragInfo\n    const attrName = barType === 'bottom' ? 'clientX' : 'clientY'\n    const offset = this.dragInfo.offset = event[attrName] - this.dragInfo[attrName]\n    if (Math.abs(offset) < 5) {\n      return\n    }\n    this.isDragTableBar = true\n    this.hideUnnecessaryBar()\n    this.calculateCurIndex()\n    this.setDragTargetStyle()\n    this.setSwitchStyle()\n  }\n\n  ContentState.prototype.handleMouseUp = function (event) {\n    const { eventCenter } = this.muya\n    for (const id of this.dragEventIds) {\n      eventCenter.detachDOMEvent(id)\n    }\n    this.dragEventIds = []\n    if (!this.isDragTableBar) {\n      return\n    }\n\n    this.setDropTargetStyle()\n\n    // The drop animation need 300ms.\n    setTimeout(() => {\n      this.switchTableData()\n      this.resetDragTableBar()\n    }, 300)\n  }\n\n  ContentState.prototype.hideUnnecessaryBar = function () {\n    const { barType } = this.dragInfo\n    const hideClassName = barType === 'bottom' ? 'left' : 'bottom'\n    const needHideBar = document.querySelector(`.ag-drag-handler.${hideClassName}`)\n    if (needHideBar) {\n      needHideBar.style.display = 'none'\n    }\n  }\n\n  ContentState.prototype.calculateCurIndex = function () {\n    let { offset, aspects, index } = this.dragInfo\n    let curIndex = index\n    const len = aspects.length\n    let i\n    if (offset > 0) {\n      for (i = index; i < len; i++) {\n        const aspect = aspects[i]\n        if (i === index) {\n          offset -= Math.floor(aspect / 2)\n        } else {\n          offset -= aspect\n        }\n        if (offset < 0) {\n          break\n        } else {\n          curIndex++\n        }\n      }\n    } else if (offset < 0) {\n      for (i = index; i >= 0; i--) {\n        const aspect = aspects[i]\n        if (i === index) {\n          offset += Math.floor(aspect / 2)\n        } else {\n          offset += aspect\n        }\n        if (offset > 0) {\n          break\n        } else {\n          curIndex--\n        }\n      }\n    }\n\n    this.dragInfo.curIndex = Math.max(0, Math.min(curIndex, len - 1))\n  }\n\n  ContentState.prototype.setDragTargetStyle = function () {\n    const { offset, barType, dragCells } = this.dragInfo\n\n    for (const cell of dragCells) {\n      if (!cell.classList.contains('ag-drag-cell')) {\n        cell.classList.add('ag-drag-cell')\n        cell.classList.add(`ag-drag-${barType}`)\n      }\n      const valueName = barType === 'bottom' ? 'translateX' : 'translateY'\n      cell.style.transform = `${valueName}(${offset}px)`\n    }\n  }\n\n  ContentState.prototype.setSwitchStyle = function () {\n    const { index, offset, curIndex, barType, aspects, cells } = this.dragInfo\n    const aspect = aspects[index]\n    const len = aspects.length\n\n    let i\n    if (offset > 0) {\n      if (barType === 'bottom') {\n        for (const row of cells) {\n          for (i = 0; i < len; i++) {\n            const cell = row[i]\n            if (i > index && i <= curIndex) {\n              cell.style.transform = `translateX(${-aspect}px)`\n            } else if (i !== index) {\n              cell.style.transform = 'translateX(0px)'\n            }\n          }\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          const row = cells[i]\n          for (const cell of row) {\n            if (i > index && i <= curIndex) {\n              cell.style.transform = `translateY(${-aspect}px)`\n            } else if (i !== index) {\n              cell.style.transform = 'translateY(0px)'\n            }\n          }\n        }\n      }\n    } else {\n      if (barType === 'bottom') {\n        for (const row of cells) {\n          for (i = 0; i < len; i++) {\n            const cell = row[i]\n            if (i >= curIndex && i < index) {\n              cell.style.transform = `translateX(${aspect}px)`\n            } else if (i !== index) {\n              cell.style.transform = 'translateX(0px)'\n            }\n          }\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          const row = cells[i]\n          for (const cell of row) {\n            if (i >= curIndex && i < index) {\n              cell.style.transform = `translateY(${aspect}px)`\n            } else if (i !== index) {\n              cell.style.transform = 'translateY(0px)'\n            }\n          }\n        }\n      }\n    }\n  }\n\n  ContentState.prototype.setDropTargetStyle = function () {\n    const { dragCells, barType, curIndex, index, aspects, offset } = this.dragInfo\n    let move = 0\n    let i\n    if (offset > 0) {\n      for (i = index + 1; i <= curIndex; i++) {\n        move += aspects[i]\n      }\n    } else {\n      for (i = curIndex; i < index; i++) {\n        move -= aspects[i]\n      }\n    }\n    for (const cell of dragCells) {\n      cell.classList.remove('ag-drag-cell')\n      cell.classList.remove(`ag-drag-${barType}`)\n      cell.classList.add('ag-cell-transform')\n      const valueName = barType === 'bottom' ? 'translateX' : 'translateY'\n      cell.style.transform = `${valueName}(${move}px)`\n    }\n  }\n\n  ContentState.prototype.switchTableData = function () {\n    const { barType, index, curIndex, tableId, offset } = this.dragInfo\n    const table = this.getBlock(tableId)\n    const tHead = table.children[0]\n    const tBody = table.children[1]\n    const rows = [tHead.children[0], ...(tBody ? tBody.children : [])]\n    let i\n\n    if (index !== curIndex) {\n      // Cursor in the same cell.\n      const { start, end } = this.cursor\n      let key = null\n      if (barType === 'bottom') {\n        for (const row of rows) {\n          const isCursorCell = row.children[index].children[0].key === start.key\n          const { text } = row.children[index].children[0]\n          const { align } = row.children[index]\n          if (offset > 0) {\n            for (i = index; i < curIndex; i++) {\n              row.children[i].children[0].text = row.children[i + 1].children[0].text\n              row.children[i].align = row.children[i + 1].align\n            }\n            row.children[curIndex].children[0].text = text\n            row.children[curIndex].align = align\n          } else {\n            for (i = index; i > curIndex; i--) {\n              row.children[i].children[0].text = row.children[i - 1].children[0].text\n              row.children[i].align = row.children[i - 1].align\n            }\n            row.children[curIndex].children[0].text = text\n            row.children[curIndex].align = align\n          }\n          if (isCursorCell) {\n            key = row.children[curIndex].children[0].key\n          }\n        }\n      } else {\n        let column = null\n        const temp = rows[index].children.map((cell, i) => {\n          if (cell.children[0].key === start.key) {\n            column = i\n          }\n          return cell.children[0].text\n        })\n        if (offset > 0) {\n          for (i = index; i < curIndex; i++) {\n            rows[i].children.forEach((cell, ii) => {\n              cell.children[0].text = rows[i + 1].children[ii].children[0].text\n            })\n          }\n          rows[curIndex].children.forEach((cell, i) => {\n            if (i === column) {\n              key = cell.children[0].key\n            }\n            cell.children[0].text = temp[i]\n          })\n        } else {\n          for (i = index; i > curIndex; i--) {\n            rows[i].children.forEach((cell, ii) => {\n              cell.children[0].text = rows[i - 1].children[ii].children[0].text\n            })\n          }\n          rows[curIndex].children.forEach((cell, i) => {\n            if (i === column) {\n              key = cell.children[0].key\n            }\n            cell.children[0].text = temp[i]\n          })\n        }\n      }\n      if (key) {\n        this.cursor = {\n          start: {\n            key,\n            offset: start.offset\n          },\n          end: {\n            key,\n            offset: end.offset\n          }\n        }\n        return this.singleRender(table)\n      } else {\n        return this.partialRender()\n      }\n    }\n  }\n\n  ContentState.prototype.resetDragTableBar = function () {\n    this.dragInfo = null\n    this.isDragTableBar = false\n  }\n}\n\nexport default tableDragBarCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\copyCutCtrl.js",["548","549"],"import selection from '../selection'\nimport { CLASS_OR_ID } from '../config'\nimport { escapeHtml } from '../utils'\nimport { getSanitizeHtml } from '../utils/exportHtml'\nimport ExportMarkdown from '../utils/exportMarkdown'\nimport marked from '../parser/marked'\n\nconst copyCutCtrl = ContentState => {\n  ContentState.prototype.docCutHandler = function (event) {\n    const { selectedTableCells } = this\n    if (selectedTableCells) {\n      event.preventDefault()\n      return this.deleteSelectedTableCells(true)\n    }\n  }\n\n  ContentState.prototype.cutHandler = function () {\n    if (this.selectedTableCells) {\n      return\n    }\n    const { selectedImage } = this\n    if (selectedImage) {\n      const { key, token } = selectedImage\n      this.deleteImage({\n        key,\n        token\n      })\n      return\n    }\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return\n    }\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    startBlock.text = startBlock.text.substring(0, start.offset) + endBlock.text.substring(end.offset)\n    if (start.key !== end.key) {\n      this.removeBlocks(startBlock, endBlock)\n    }\n    this.cursor = {\n      start,\n      end: start\n    }\n    this.checkInlineUpdate(startBlock)\n    this.partialRender()\n  }\n\n  ContentState.prototype.getClipBoradData = function () {\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return { html: '', text: '' }\n    }\n    if (start.key === end.key) {\n      const startBlock = this.getBlock(start.key)\n      const { type, text, functionType } = startBlock\n      // Fix issue #942\n      if (type === 'span' && functionType === 'codeContent') {\n        const selectedText = text.substring(start.offset, end.offset)\n        return {\n          html: marked(selectedText, this.muya.options),\n          text: selectedText\n        }\n      }\n    }\n    const html = selection.getSelectionHtml()\n    const wrapper = document.createElement('div')\n    wrapper.innerHTML = html\n    const removedElements = wrapper.querySelectorAll(\n      `.${CLASS_OR_ID.AG_TOOL_BAR},\n      .${CLASS_OR_ID.AG_MATH_RENDER},\n      .${CLASS_OR_ID.AG_RUBY_RENDER},\n      .${CLASS_OR_ID.AG_HTML_PREVIEW},\n      .${CLASS_OR_ID.AG_MATH_PREVIEW},\n      .${CLASS_OR_ID.AG_COPY_REMOVE},\n      .${CLASS_OR_ID.AG_LANGUAGE_INPUT},\n      .${CLASS_OR_ID.AG_HTML_TAG} br,\n      .${CLASS_OR_ID.AG_FRONT_ICON}`\n    )\n\n    for (const e of removedElements) {\n      e.remove()\n    }\n\n    // Fix #1678 copy task list, and the first list item is not task list item.\n    const taskListItems = wrapper.querySelectorAll('li.ag-task-list-item')\n    for (const item of taskListItems) {\n      const firstChild = item.firstElementChild\n      if (firstChild && firstChild.nodeName !== 'INPUT') {\n        const originItem = document.querySelector(`#${item.id}`)\n        let checked = false\n        if (originItem && originItem.firstElementChild && originItem.firstElementChild.nodeName === 'INPUT') {\n          checked = originItem.firstElementChild.checked\n        }\n\n        const input = document.createElement('input')\n        input.setAttribute('type', 'checkbox')\n        if (checked) {\n          input.setAttribute('checked', true)\n        }\n\n        item.insertBefore(input, firstChild)\n      }\n    }\n\n    const images = wrapper.querySelectorAll('span.ag-inline-image img')\n    for (const image of images) {\n      const src = image.getAttribute('src')\n      let originSrc = null\n      for (const [sSrc, tSrc] of this.stateRender.urlMap.entries()) {\n        if (tSrc === src) {\n          originSrc = sSrc\n          break\n        }\n      }\n\n      if (originSrc) {\n        image.setAttribute('src', originSrc)\n      }\n    }\n\n    const hrs = wrapper.querySelectorAll('[data-role=hr]')\n    for (const hr of hrs) {\n      hr.replaceWith(document.createElement('hr'))\n    }\n\n    const headers = wrapper.querySelectorAll('[data-head]')\n    for (const header of headers) {\n      const p = document.createElement('p')\n      p.textContent = header.textContent\n      header.replaceWith(p)\n    }\n\n    // replace inline rule element: code, a, strong, em, del, auto_link to span element\n    // in order to escape turndown translation\n\n    const inlineRuleElements = wrapper.querySelectorAll(\n      `a.${CLASS_OR_ID.AG_INLINE_RULE},\n      code.${CLASS_OR_ID.AG_INLINE_RULE},\n      strong.${CLASS_OR_ID.AG_INLINE_RULE},\n      em.${CLASS_OR_ID.AG_INLINE_RULE},\n      del.${CLASS_OR_ID.AG_INLINE_RULE}`\n    )\n    for (const e of inlineRuleElements) {\n      const span = document.createElement('span')\n      span.textContent = e.textContent\n      e.replaceWith(span)\n    }\n\n    const aLinks = wrapper.querySelectorAll(`.${CLASS_OR_ID.AG_A_LINK}`)\n    for (const l of aLinks) {\n      const span = document.createElement('span')\n      span.innerHTML = l.innerHTML\n      l.replaceWith(span)\n    }\n\n    const codefense = wrapper.querySelectorAll('pre[data-role$=\\'code\\']')\n    for (const cf of codefense) {\n      const id = cf.id\n      const block = this.getBlock(id)\n      const language = block.lang || ''\n      const codeContent = cf.querySelector('.ag-code-content')\n      const value = escapeHtml(codeContent.textContent)\n      cf.innerHTML = `<code class=\"language-${language}\">${value}</code>`\n    }\n\n    const tightListItem = wrapper.querySelectorAll('.ag-tight-list-item')\n    for (const li of tightListItem) {\n      for (const item of li.childNodes) {\n        if (item.tagName === 'P' && item.childElementCount === 1 && item.classList.contains('ag-paragraph')) {\n          li.replaceChild(item.firstElementChild, item)\n        }\n      }\n    }\n\n    const htmlBlock = wrapper.querySelectorAll('figure[data-role=\\'HTML\\']')\n    for (const hb of htmlBlock) {\n      const codeContent = hb.querySelector('.ag-code-content')\n      const pre = document.createElement('pre')\n      pre.textContent = codeContent.textContent\n      hb.replaceWith(pre)\n    }\n\n    // Just work for turndown, turndown will add `leading` and `traling` space in line-break.\n    const lineBreaks = wrapper.querySelectorAll('span.ag-soft-line-break, span.ag-hard-line-break')\n    for (const b of lineBreaks) {\n      b.innerHTML = ''\n    }\n\n    const mathBlock = wrapper.querySelectorAll('figure.ag-container-block')\n    for (const mb of mathBlock) {\n      const preElement = mb.querySelector('pre[data-role]')\n      const functionType = preElement.getAttribute('data-role')\n      const codeContent = mb.querySelector('.ag-code-content')\n      const value = codeContent.textContent\n      let pre\n      switch (functionType) {\n        case 'multiplemath':\n          pre = document.createElement('pre')\n          pre.classList.add('multiple-math')\n          pre.textContent = value\n          mb.replaceWith(pre)\n          break\n        case 'mermaid':\n        case 'flowchart':\n        case 'sequence':\n        case 'vega-lite':\n          pre = document.createElement('pre')\n          pre.innerHTML = `<code class=\"language-${functionType}\">${value}</code>`\n          mb.replaceWith(pre)\n          break\n      }\n    }\n\n    let htmlData = wrapper.innerHTML\n    const textData = this.htmlToMarkdown(htmlData)\n    htmlData = marked(textData)\n\n    return { html: htmlData, text: textData }\n  }\n\n  ContentState.prototype.docCopyHandler = function (event) {\n    const { selectedTableCells } = this\n    if (selectedTableCells) {\n      event.preventDefault()\n      const { row, column, cells } = selectedTableCells\n      const tableContents = []\n      let i\n      let j\n      for (i = 0; i < row; i++) {\n        const rowWrapper = []\n        for (j = 0; j < column; j++) {\n          const cell = cells[i * column + j]\n\n          rowWrapper.push({\n            text: cell.text,\n            align: cell.align\n          })\n        }\n        tableContents.push(rowWrapper)\n      }\n\n      if (row === 1 && column === 1) {\n        // Copy cells text if only one is selected\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', tableContents[0][0].text)\n      } else {\n        // Copy as markdown table\n        const figureBlock = this.createBlock('figure', {\n          functionType: 'table'\n        })\n        const table = this.createTableInFigure({ rows: row, columns: column }, tableContents)\n        this.appendChild(figureBlock, table)\n        const { isGitlabCompatibilityEnabled, listIndentation } = this\n        const markdown = new ExportMarkdown([figureBlock], listIndentation, isGitlabCompatibilityEnabled).generate()\n\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', markdown)\n      }\n    }\n  }\n\n  ContentState.prototype.copyHandler = function (event, type, copyInfo = null) {\n    if (this.selectedTableCells) {\n      // Hand over to docCopyHandler\n      return\n    }\n    event.preventDefault()\n    const { selectedImage } = this\n    if (selectedImage) {\n      const { token } = selectedImage\n      event.clipboardData.setData('text/html', token.raw)\n      event.clipboardData.setData('text/plain', token.raw)\n      return\n    }\n\n    const { html, text } = this.getClipBoradData()\n    switch (type) {\n      case 'normal': {\n        event.clipboardData.setData('text/html', html)\n        event.clipboardData.setData('text/plain', text)\n        break\n      }\n      case 'copyAsMarkdown': {\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', text)\n        break\n      }\n      case 'copyAsHtml': {\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', getSanitizeHtml(text, {\n          superSubScript: this.muya.options.superSubScript,\n          footnote: this.muya.options.footnote,\n          isGitlabCompatibilityEnabled: this.muya.options.isGitlabCompatibilityEnabled\n        }))\n        break\n      }\n\n      case 'copyBlock': {\n        const block = typeof copyInfo === 'string' ? this.getBlock(copyInfo) : copyInfo\n        if (!block) return\n        const anchor = this.getAnchor(block)\n        const { isGitlabCompatibilityEnabled, listIndentation } = this\n        const markdown = new ExportMarkdown([anchor], listIndentation, isGitlabCompatibilityEnabled).generate()\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', markdown)\n        break\n      }\n\n      case 'copyCodeContent': {\n        const codeContent = copyInfo\n        if (typeof codeContent !== 'string') {\n          return\n        }\n        event.clipboardData.setData('text/html', '')\n        event.clipboardData.setData('text/plain', codeContent)\n      }\n    }\n  }\n}\n\nexport default copyCutCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\arrowCtrl.js",["550"],"import { EVENT_KEYS, CLASS_OR_ID } from '../config'\nimport { findNearestParagraph } from '../selection/dom'\nimport selection from '../selection'\n\n// If the next block is header, put cursor after the `#{1,6} *`\nconst adjustOffset = (offset, block, event) => {\n  if (/^span$/.test(block.type) && block.functionType === 'atxLine' && event.key === EVENT_KEYS.ArrowDown) {\n    const match = /^\\s{0,3}(?:#{1,6})(?:\\s{1,}|$)/.exec(block.text)\n    if (match) {\n      return match[0].length\n    }\n  }\n  return offset\n}\n\nconst arrowCtrl = ContentState => {\n  ContentState.prototype.findNextRowCell = function (cell) {\n    if (cell.functionType !== 'cellContent') {\n      throw new Error(`block with type ${cell && cell.type} is not a table cell`)\n    }\n    const thOrTd = this.getParent(cell)\n    const row = this.closest(cell, 'tr')\n    const rowContainer = this.closest(row, /thead|tbody/) // thead or tbody\n    const column = row.children.indexOf(thOrTd)\n    if (rowContainer.type === 'thead') {\n      const tbody = this.getNextSibling(rowContainer)\n      if (tbody && tbody.children.length) {\n        return tbody.children[0].children[column].children[0]\n      }\n    } else if (rowContainer.type === 'tbody') {\n      const nextRow = this.getNextSibling(row)\n      if (nextRow) {\n        return nextRow.children[column].children[0]\n      }\n    }\n    return null\n  }\n\n  ContentState.prototype.findPrevRowCell = function (cell) {\n    if (cell.functionType !== 'cellContent') {\n      throw new Error(`block with type ${cell && cell.type} is not a table cell`)\n    }\n    const thOrTd = this.getParent(cell)\n    const row = this.closest(cell, 'tr')\n    const rowContainer = this.getParent(row) // thead or tbody\n    const rowIndex = rowContainer.children.indexOf(row)\n    const column = row.children.indexOf(thOrTd)\n    if (rowContainer.type === 'tbody') {\n      if (rowIndex === 0 && rowContainer.preSibling) {\n        const thead = this.getPreSibling(rowContainer)\n        return thead.children[0].children[column].children[0]\n      } else if (rowIndex > 0) {\n        return this.getPreSibling(row).children[column].children[0]\n      }\n      return null\n    }\n    return null\n  }\n\n  ContentState.prototype.docArrowHandler = function (event) {\n    const { selectedImage } = this\n    if (selectedImage) {\n      const { key, token } = selectedImage\n      const { start, end } = token.range\n      event.preventDefault()\n      event.stopPropagation()\n      const block = this.getBlock(key)\n      switch (event.key) {\n        case EVENT_KEYS.ArrowUp:\n        case EVENT_KEYS.ArrowLeft: {\n          this.cursor = {\n            start: { key, offset: start },\n            end: { key, offset: start }\n          }\n          break\n        }\n        case EVENT_KEYS.ArrowDown:\n        case EVENT_KEYS.ArrowRight: {\n          this.cursor = {\n            start: { key, offset: end },\n            end: { key, offset: end }\n          }\n          break\n        }\n      }\n      this.muya.keyboard.hideAllFloatTools()\n      return this.singleRender(block)\n    }\n  }\n\n  ContentState.prototype.arrowHandler = function (event) {\n    const node = selection.getSelectionStart()\n    const paragraph = findNearestParagraph(node)\n    const id = paragraph.id\n    const block = this.getBlock(id)\n    const preBlock = this.findPreBlockInLocation(block)\n    const nextBlock = this.findNextBlockInLocation(block)\n    const { start, end } = selection.getCursorRange()\n    const { topOffset, bottomOffset } = selection.getCursorYOffset(paragraph)\n    if (!start || !end) {\n      return\n    }\n\n    // fix #101\n    if (event.key === EVENT_KEYS.ArrowRight && node && node.classList && node.classList.contains(CLASS_OR_ID.AG_MATH_TEXT)) {\n      const { right } = selection.getCaretOffsets(node)\n      if (right === 0 && start.key === end.key && start.offset === end.offset) {\n        // It's not recommended to use such lower API, but it's work well.\n        return selection.select(node.parentNode.nextElementSibling, 0)\n      }\n    }\n\n    // Just do nothing if the cursor is not collapsed or `shiftKey` pressed\n    if (\n      (start.key === end.key && start.offset !== end.offset) ||\n      start.key !== end.key || event.shiftKey\n    ) {\n      return\n    }\n\n    if (\n      (event.key === EVENT_KEYS.ArrowUp && topOffset > 0) ||\n      (event.key === EVENT_KEYS.ArrowDown && bottomOffset > 0)\n    ) {\n      if (!/pre/.test(block.type) || block.functionType !== 'cellContent') {\n        return\n      }\n    }\n\n    if (block.functionType === 'cellContent') {\n      let activeBlock\n      const cellInNextRow = this.findNextRowCell(block)\n      const cellInPrevRow = this.findPrevRowCell(block)\n\n      if (event.key === EVENT_KEYS.ArrowUp) {\n        if (cellInPrevRow) {\n          activeBlock = cellInPrevRow\n        } else {\n          activeBlock = this.findPreBlockInLocation(this.getTableBlock())\n        }\n      }\n\n      if (event.key === EVENT_KEYS.ArrowDown) {\n        if (cellInNextRow) {\n          activeBlock = cellInNextRow\n        } else {\n          activeBlock = this.findNextBlockInLocation(this.getTableBlock())\n        }\n      }\n\n      if (activeBlock) {\n        event.preventDefault()\n        event.stopPropagation()\n        let offset = activeBlock.type === 'p'\n          ? 0\n          : (event.key === EVENT_KEYS.ArrowUp\n            ? activeBlock.text.length\n            : 0)\n\n        offset = adjustOffset(offset, activeBlock, event)\n\n        const key = activeBlock.type === 'p'\n          ? activeBlock.children[0].key\n          : activeBlock.key\n\n        this.cursor = {\n          start: {\n            key,\n            offset\n          },\n          end: {\n            key,\n            offset\n          }\n        }\n\n        return this.partialRender()\n      }\n    }\n\n    if (\n      (event.key === EVENT_KEYS.ArrowUp) ||\n      (event.key === EVENT_KEYS.ArrowLeft && start.offset === 0)\n    ) {\n      event.preventDefault()\n      event.stopPropagation()\n      if (!preBlock) return\n      const key = preBlock.key\n      const offset = preBlock.text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.partialRender()\n    } else if (\n      (event.key === EVENT_KEYS.ArrowDown) ||\n      (event.key === EVENT_KEYS.ArrowRight && start.offset === block.text.length)\n    ) {\n      event.preventDefault()\n      event.stopPropagation()\n      let key\n      let newBlock\n      if (nextBlock) {\n        key = nextBlock.key\n      } else {\n        newBlock = this.createBlockP()\n        const lastBlock = this.blocks[this.blocks.length - 1]\n        this.insertAfter(newBlock, lastBlock)\n        key = newBlock.children[0].key\n      }\n      const offset = adjustOffset(0, nextBlock || newBlock, event)\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.partialRender()\n    }\n  }\n}\n\nexport default arrowCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tableBlockCtrl.js",["551","552"],"import { isLengthEven, getParagraphReference } from '../utils'\n\nconst TABLE_BLOCK_REG = /^\\|.*?(\\\\*)\\|.*?(\\\\*)\\|/\n\nconst tableBlockCtrl = ContentState => {\n  ContentState.prototype.createTableInFigure = function ({ rows, columns }, tableContents = []) {\n    const table = this.createBlock('table', {\n      row: rows - 1, // zero base\n      column: columns - 1\n    })\n    const tHead = this.createBlock('thead')\n    const tBody = this.createBlock('tbody')\n\n    let i\n    let j\n    for (i = 0; i < rows; i++) {\n      const rowBlock = this.createBlock('tr')\n      i === 0 ? this.appendChild(tHead, rowBlock) : this.appendChild(tBody, rowBlock)\n      const rowContents = tableContents[i]\n      for (j = 0; j < columns; j++) {\n        const cell = this.createBlock(i === 0 ? 'th' : 'td', {\n          align: rowContents ? rowContents[j].align : '',\n          column: j\n        })\n        const cellContent = this.createBlock('span', {\n          text: rowContents ? rowContents[j].text : '',\n          functionType: 'cellContent'\n        })\n\n        this.appendChild(cell, cellContent)\n        this.appendChild(rowBlock, cell)\n      }\n    }\n\n    this.appendChild(table, tHead)\n    if (tBody.children.length) {\n      this.appendChild(table, tBody)\n    }\n\n    return table\n  }\n\n  ContentState.prototype.createFigure = function ({ rows, columns }) {\n    const { end } = this.cursor\n    const table = this.createTableInFigure({ rows, columns })\n    const figureBlock = this.createBlock('figure', {\n      functionType: 'table'\n    })\n    const endBlock = this.getBlock(end.key)\n    const anchor = this.getAnchor(endBlock)\n\n    if (!anchor) {\n      return\n    }\n\n    this.insertAfter(figureBlock, anchor)\n    if (/p|h\\d/.test(anchor.type) && !endBlock.text) {\n      this.removeBlock(anchor)\n    }\n    this.appendChild(figureBlock, table)\n    const { key } = this.firstInDescendant(table) // fist cell key in thead\n    const offset = 0\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n    this.partialRender()\n  }\n\n  ContentState.prototype.createTable = function (tableChecker) {\n    this.createFigure(tableChecker)\n\n    this.muya.dispatchSelectionChange()\n    this.muya.dispatchSelectionFormats()\n    this.muya.dispatchChange()\n  }\n\n  ContentState.prototype.initTable = function (block) {\n    const { text } = block.children[0]\n    const rowHeader = []\n    const len = text.length\n    let i\n    for (i = 0; i < len; i++) {\n      const char = text[i]\n      if (/^[^|]$/.test(char)) {\n        rowHeader[rowHeader.length - 1] += char\n      }\n      if (/\\\\/.test(char)) {\n        rowHeader[rowHeader.length - 1] += text[++i]\n      }\n      if (/\\|/.test(char) && i !== len - 1) {\n        rowHeader.push('')\n      }\n    }\n\n    const columns = rowHeader.length\n    const rows = 2\n\n    const table = this.createTableInFigure({ rows, columns }, [rowHeader.map(text => ({ text, align: '' }))])\n\n    block.type = 'figure'\n    block.text = ''\n    block.children = []\n    block.functionType = 'table'\n    this.appendChild(block, table)\n\n    return this.firstInDescendant(table.children[1]) // first cell content in tbody\n  }\n\n  ContentState.prototype.tableToolBarClick = function (type) {\n    const { start: { key } } = this.cursor\n    const block = this.getBlock(key)\n    const parentBlock = this.getParent(block)\n    if (block.functionType !== 'cellContent') {\n      throw new Error('table is not active')\n    }\n    const { column, align } = parentBlock\n    const table = this.closest(block, 'table')\n    const figure = this.getBlock(table.parent)\n\n    switch (type) {\n      case 'left':\n      case 'center':\n      case 'right': {\n        const newAlign = align === type ? '' : type\n        table.children.forEach(rowContainer => {\n          rowContainer.children.forEach(row => {\n            row.children[column].align = newAlign\n          })\n        })\n        this.muya.eventCenter.dispatch('stateChange')\n        this.partialRender()\n        break\n      }\n      case 'delete': {\n        const newLine = this.createBlock('span')\n        figure.children = []\n        this.appendChild(figure, newLine)\n        figure.type = 'p'\n        figure.text = ''\n        const key = newLine.key\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        this.muya.eventCenter.dispatch('stateChange')\n        this.partialRender()\n        break\n      }\n      case 'table': {\n        const { eventCenter } = this.muya\n        const figureKey = figure.key\n        const tableEle = document.querySelector(`#${figureKey} [data-label=table]`)\n        const { row = 1, column = 1 } = table // zero base\n\n        const handler = (row, column) => {\n          const { row: oldRow, column: oldColumn } = table\n          let tBody = table.children[1]\n          const tHead = table.children[0]\n          const headerRow = tHead.children[0]\n          const bodyRows = tBody ? tBody.children : []\n          let i\n          if (column > oldColumn) {\n            for (i = oldColumn + 1; i <= column; i++) {\n              const th = this.createBlock('th', {\n                column: i,\n                align: ''\n              })\n              const thContent = this.createBlock('span', {\n                functionType: 'cellContent'\n              })\n              this.appendChild(th, thContent)\n              this.appendChild(headerRow, th)\n              bodyRows.forEach(bodyRow => {\n                const td = this.createBlock('td', {\n                  column: i,\n                  align: ''\n                })\n\n                const tdContent = this.createBlock('span', {\n                  functionType: 'cellContent'\n                })\n                this.appendChild(td, tdContent)\n                this.appendChild(bodyRow, td)\n              })\n            }\n          } else if (column < oldColumn) {\n            const rows = [headerRow, ...bodyRows]\n            rows.forEach(row => {\n              while (row.children.length > column + 1) {\n                const lastChild = row.children[row.children.length - 1]\n                this.removeBlock(lastChild)\n              }\n            })\n          }\n\n          if (row < oldRow) {\n            while (tBody.children.length > row) {\n              const lastRow = tBody.children[tBody.children.length - 1]\n              this.removeBlock(lastRow)\n            }\n            if (tBody.children.length === 0) {\n              this.removeBlock(tBody)\n            }\n          } else if (row > oldRow) {\n            if (!tBody) {\n              tBody = this.createBlock('tbody')\n              this.appendChild(table, tBody)\n            }\n            const oneHeaderRow = tHead.children[0]\n            for (i = oldRow + 1; i <= row; i++) {\n              const bodyRow = this.createRow(oneHeaderRow, false)\n\n              this.appendChild(tBody, bodyRow)\n            }\n          }\n\n          Object.assign(table, { row, column })\n\n          const cursorBlock = this.firstInDescendant(headerRow)\n          const key = cursorBlock.key\n          const offset = cursorBlock.text.length\n          this.cursor = {\n            start: { key, offset },\n            end: { key, offset }\n          }\n          this.muya.eventCenter.dispatch('stateChange')\n          this.partialRender()\n        }\n\n        const reference = getParagraphReference(tableEle, tableEle.id)\n        eventCenter.dispatch('muya-table-picker', { row, column }, reference, handler.bind(this))\n      }\n    }\n  }\n\n  // insert/remove row/column\n  ContentState.prototype.editTable = function ({ location, action, target }, cellContentKey) {\n    let block\n    let start\n    let end\n    if (cellContentKey) {\n      block = this.getBlock(cellContentKey)\n    } else {\n      ({ start, end } = this.cursor)\n      if (start.key !== end.key) {\n        throw new Error('Cursor is not in one block, can not editTable')\n      }\n\n      block = this.getBlock(start.key)\n    }\n\n    if (block.functionType !== 'cellContent') {\n      throw new Error('Cursor is not in table block, so you can not insert/edit row/column')\n    }\n\n    const cellBlock = this.getParent(block)\n    const currentRow = this.getParent(cellBlock)\n    const table = this.closest(block, 'table')\n    const thead = table.children[0]\n    const tbody = table.children[1]\n    const columnIndex = currentRow.children.indexOf(cellBlock)\n    // const rowIndex = rowContainer.type === 'thead' ? 0 : tbody.children.indexOf(currentRow) + 1\n\n    let cursorBlock\n\n    if (target === 'row') {\n      if (action === 'insert') {\n        const newRow = (location === 'previous' && cellBlock.type === 'th')\n          ? this.createRow(currentRow, true)\n          : this.createRow(currentRow, false)\n        if (location === 'previous') {\n          this.insertBefore(newRow, currentRow)\n          if (cellBlock.type === 'th') {\n            this.removeBlock(currentRow)\n            currentRow.children.forEach(cell => (cell.type = 'td'))\n            const firstRow = tbody.children[0]\n            this.insertBefore(currentRow, firstRow)\n          }\n        } else {\n          if (cellBlock.type === 'th') {\n            const firstRow = tbody.children[0]\n            this.insertBefore(newRow, firstRow)\n          } else {\n            this.insertAfter(newRow, currentRow)\n          }\n        }\n        cursorBlock = newRow.children[columnIndex].children[0]\n        // handle remove row\n      } else {\n        if (location === 'previous') {\n          if (cellBlock.type === 'th') return\n          if (!currentRow.preSibling) {\n            const headRow = thead.children[0]\n            if (!currentRow.nextSibling) return\n            this.removeBlock(headRow)\n            this.removeBlock(currentRow)\n            currentRow.children.forEach(cell => (cell.type = 'th'))\n            this.appendChild(thead, currentRow)\n          } else {\n            const preRow = this.getPreSibling(currentRow)\n            this.removeBlock(preRow)\n          }\n        } else if (location === 'current') {\n          if (cellBlock.type === 'th' && tbody.children.length >= 2) {\n            const firstRow = tbody.children[0]\n            this.removeBlock(currentRow)\n            this.removeBlock(firstRow)\n            this.appendChild(thead, firstRow)\n            firstRow.children.forEach(cell => (cell.type = 'th'))\n            cursorBlock = firstRow.children[columnIndex].children[0]\n          }\n          if (cellBlock.type === 'td' && (currentRow.preSibling || currentRow.nextSibling)) {\n            cursorBlock = (this.getNextSibling(currentRow) || this.getPreSibling(currentRow)).children[columnIndex].children[0]\n            this.removeBlock(currentRow)\n          }\n        } else {\n          if (cellBlock.type === 'th') {\n            if (tbody.children.length >= 2) {\n              const firstRow = tbody.children[0]\n              this.removeBlock(firstRow)\n            } else {\n              return\n            }\n          } else {\n            const nextRow = this.getNextSibling(currentRow)\n            if (nextRow) {\n              this.removeBlock(nextRow)\n            }\n          }\n        }\n      }\n    } else if (target === 'column') {\n      if (action === 'insert') {\n        [...thead.children, ...tbody.children].forEach(tableRow => {\n          const targetCell = tableRow.children[columnIndex]\n          const cell = this.createBlock(targetCell.type, {\n            align: ''\n          })\n          const cellContent = this.createBlock('span', {\n            functionType: 'cellContent'\n          })\n          this.appendChild(cell, cellContent)\n          if (location === 'left') {\n            this.insertBefore(cell, targetCell)\n          } else {\n            this.insertAfter(cell, targetCell)\n          }\n          tableRow.children.forEach((cell, i) => {\n            cell.column = i\n          })\n        })\n        cursorBlock = location === 'left' ? this.getPreSibling(cellBlock).children[0] : this.getNextSibling(cellBlock).children[0]\n        // handle remove column\n      } else {\n        if (currentRow.children.length <= 2) return\n        [...thead.children, ...tbody.children].forEach(tableRow => {\n          const targetCell = tableRow.children[columnIndex]\n          const removeCell = location === 'left'\n            ? this.getPreSibling(targetCell)\n            : (location === 'current' ? targetCell : this.getNextSibling(targetCell))\n          if (removeCell === cellBlock) {\n            cursorBlock = this.findNextBlockInLocation(block)\n          }\n\n          if (removeCell) this.removeBlock(removeCell)\n          tableRow.children.forEach((cell, i) => {\n            cell.column = i\n          })\n        })\n      }\n    }\n\n    const newColum = thead.children[0].children.length - 1\n    const newRow = thead.children.length + tbody.children.length - 1\n    Object.assign(table, { row: newRow, column: newColum })\n\n    if (cursorBlock) {\n      const { key } = cursorBlock\n      const offset = 0\n      this.cursor = { start: { key, offset }, end: { key, offset } }\n    } else {\n      this.cursor = { start, end }\n    }\n\n    this.partialRender()\n    this.muya.eventCenter.dispatch('stateChange')\n  }\n\n  ContentState.prototype.getTableBlock = function () {\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const startParents = this.getParents(startBlock)\n    const endParents = this.getParents(endBlock)\n    const affiliation = startParents\n      .filter(p => endParents.includes(p))\n\n    if (affiliation.length) {\n      const figure = affiliation.find(p => p.type === 'figure')\n      return figure\n    }\n  }\n\n  ContentState.prototype.tableBlockUpdate = function (block) {\n    const { type } = block\n    if (type !== 'p') return false\n    const { text } = block.children[0]\n    const match = TABLE_BLOCK_REG.exec(text)\n    return (match && isLengthEven(match[1]) && isLengthEven(match[2])) ? this.initTable(block) : false\n  }\n}\n\nexport default tableBlockCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tableSelectCellsCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\paragraphCtrl.js",["553","554","555","556"],"import selection from '../selection'\nimport { PARAGRAPH_TYPES, DEFAULT_TURNDOWN_CONFIG } from '../config'\nimport ExportMarkdown from '../utils/exportMarkdown'\n\n// get header level\n//  eg: h1 => 1\n//      h2 => 2\nconst getCurrentLevel = type => {\n  if (/\\d/.test(type)) {\n    return Number(/\\d/.exec(type)[0])\n  } else {\n    return 0\n  }\n}\n\nconst paragraphCtrl = ContentState => {\n  ContentState.prototype.selectionChange = function (cursor) {\n    const { start, end } = cursor || selection.getCursorRange()\n    if (!start || !end) {\n      // TODO: Throw an exception and try to fix this later (GH#848).\n      throw new Error('selectionChange: expected cursor but cursor is null.')\n    }\n    const cursorCoords = selection.getCursorCoords()\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const startParents = this.getParents(startBlock)\n    const endParents = this.getParents(endBlock)\n    const affiliation = startParents\n      .filter(p => endParents.includes(p))\n      .filter(p => PARAGRAPH_TYPES.includes(p.type))\n\n    start.type = startBlock.type\n    start.block = startBlock\n    end.type = endBlock.type\n    end.block = endBlock\n\n    return {\n      start,\n      end,\n      affiliation,\n      cursorCoords\n    }\n  }\n\n  ContentState.prototype.getCommonParent = function () {\n    const { start, end, affiliation } = this.selectionChange()\n    const parent = affiliation.length ? affiliation[0] : null\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const startParentKeys = this.getParents(startBlock).map(b => b.key)\n    const endParentKeys = this.getParents(endBlock).map(b => b.key)\n    const children = parent ? parent.children : this.blocks\n    let startIndex\n    let endIndex\n    for (const child of children) {\n      if (startParentKeys.includes(child.key)) {\n        startIndex = children.indexOf(child)\n      }\n      if (endParentKeys.includes(child.key)) {\n        endIndex = children.indexOf(child)\n      }\n    }\n    return { parent, startIndex, endIndex }\n  }\n\n  ContentState.prototype.handleFrontMatter = function () {\n    const firstBlock = this.blocks[0]\n    if (firstBlock.type === 'pre' && firstBlock.functionType === 'frontmatter') return\n\n    const { frontmatterType } = this.muya.options\n    let lang\n    let style\n    switch (frontmatterType) {\n      case '+':\n        lang = 'toml'\n        style = '+'\n        break\n      case ';':\n        lang = 'json'\n        style = ';'\n        break\n      case '{':\n        lang = 'json'\n        style = '{'\n        break\n      default:\n        lang = 'yaml'\n        style = '-'\n        break\n    }\n\n    const frontMatter = this.createBlock('pre', {\n      functionType: 'frontmatter',\n      lang,\n      style\n    })\n    const codeBlock = this.createBlock('code', {\n      lang\n    })\n    const emptyCodeContent = this.createBlock('span', {\n      functionType: 'codeContent',\n      lang\n    })\n\n    this.appendChild(codeBlock, emptyCodeContent)\n    this.appendChild(frontMatter, codeBlock)\n    this.insertBefore(frontMatter, firstBlock)\n    const { key } = emptyCodeContent\n    const offset = 0\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n  }\n\n  // TODO: New created nestled list items missing \"listType\" key and value.\n\n  ContentState.prototype.handleListMenu = function (paraType, insertMode) {\n    const { start, end, affiliation } = this.selectionChange(this.cursor)\n    const { orderListDelimiter, bulletListMarker, preferLooseListItem } = this.muya.options\n    const [blockType, listType] = paraType.split('-')\n    const isListed = affiliation.slice(0, 3).filter(b => /ul|ol/.test(b.type))\n\n    if (isListed.length && !insertMode) {\n      const listBlock = isListed[0]\n      if (listType === listBlock.listType) {\n        const listItems = listBlock.children\n        listItems.forEach(listItem => {\n          listItem.children.forEach(itemParagraph => {\n            if (itemParagraph.type !== 'input') {\n              this.insertBefore(itemParagraph, listBlock)\n            }\n          })\n        })\n        this.removeBlock(listBlock)\n        return\n      }\n      // if the old list block is task list, remove checkbox\n      if (listBlock.listType === 'task') {\n        const listItems = listBlock.children\n        listItems.forEach(item => {\n          const inputBlock = item.children[0]\n          inputBlock && this.removeBlock(inputBlock)\n        })\n      }\n      const oldListType = listBlock.listType\n      listBlock.type = blockType\n      listBlock.listType = listType\n      listBlock.children.forEach(b => (b.listItemType = listType))\n\n      if (listType === 'order') {\n        listBlock.start = listBlock.start || 1\n        listBlock.children.forEach(b => (b.bulletMarkerOrDelimiter = orderListDelimiter))\n      }\n      if (\n        (listType === 'bullet' && oldListType === 'order') ||\n        (listType === 'task' && oldListType === 'order')\n      ) {\n        delete listBlock.start\n        listBlock.children.forEach(b => (b.bulletMarkerOrDelimiter = bulletListMarker))\n      }\n\n      // if the new block is task list, add checkbox\n      if (listType === 'task') {\n        const listItems = listBlock.children\n        listItems.forEach(item => {\n          const checkbox = this.createBlock('input')\n          checkbox.checked = false\n          this.insertBefore(checkbox, item.children[0])\n        })\n      }\n    } else {\n      if (start.key === end.key || (start.block.parent && start.block.parent === end.block.parent)) {\n        const block = this.getBlock(start.key)\n        const paragraph = this.getBlock(block.parent)\n        if (listType === 'task') {\n          // 1. first update the block to bullet list\n          const listItemParagraph = this.updateList(paragraph, 'bullet', undefined, block)\n          // 2. second update bullet list to task list\n          setTimeout(() => {\n            this.updateTaskListItem(listItemParagraph, listType)\n            this.partialRender()\n            this.muya.dispatchSelectionChange()\n            this.muya.dispatchSelectionFormats()\n            this.muya.dispatchChange()\n          })\n          return false\n        } else {\n          this.updateList(paragraph, listType, undefined, block)\n        }\n      } else {\n        const { parent, startIndex, endIndex } = this.getCommonParent()\n        const children = parent ? parent.children : this.blocks\n        const referBlock = children[endIndex]\n        const listWrapper = this.createBlock(listType === 'order' ? 'ol' : 'ul')\n        listWrapper.listType = listType\n        if (listType === 'order') listWrapper.start = 1\n\n        children.slice(startIndex, endIndex + 1).forEach(child => {\n          if (child !== referBlock) {\n            this.removeBlock(child, children)\n          } else {\n            this.insertAfter(listWrapper, child)\n            this.removeBlock(child, children)\n          }\n          const listItem = this.createBlock('li')\n          listItem.listItemType = listType\n          listItem.isLooseListItem = preferLooseListItem\n          this.appendChild(listWrapper, listItem)\n          if (listType === 'task') {\n            const checkbox = this.createBlock('input')\n            checkbox.checked = false\n            this.appendChild(listItem, checkbox)\n          }\n          this.appendChild(listItem, child)\n        })\n      }\n    }\n\n    return true\n  }\n\n  ContentState.prototype.handleLooseListItem = function () {\n    const { affiliation } = this.selectionChange(this.cursor)\n    let listContainer = []\n    if (affiliation.length >= 1 && /ul|ol/.test(affiliation[0].type)) {\n      listContainer = affiliation[0].children\n    } else if (affiliation.length >= 3 && affiliation[1].type === 'li') {\n      listContainer = affiliation[2].children\n    }\n    if (listContainer.length > 0) {\n      for (const block of listContainer) {\n        block.isLooseListItem = !block.isLooseListItem\n      }\n      this.partialRender()\n    }\n  }\n\n  ContentState.prototype.handleCodeBlockMenu = function () {\n    const { start, end, affiliation } = this.selectionChange(this.cursor)\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const startParents = this.getParents(startBlock)\n    const endParents = this.getParents(endBlock)\n    const hasFencedCodeBlockParent = () => {\n      return [...startParents, ...endParents].some(b => b.type === 'pre' && /code/.test(b.functionType))\n    }\n    // change fenced code block to p paragraph\n    if (affiliation.length && affiliation[0].type === 'pre' && /code/.test(affiliation[0].functionType)) {\n      const codeBlock = affiliation[0]\n      const codeContent = codeBlock.children[1].children[0].text\n      const states = this.markdownToState(codeContent)\n\n      for (const state of states) {\n        this.insertBefore(state, codeBlock)\n      }\n\n      this.removeBlock(codeBlock)\n\n      const cursorBlock = this.firstInDescendant(states[0])\n      const { key, text } = cursorBlock\n      const offset = text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n    } else {\n      if (start.key === end.key) {\n        if (startBlock.type === 'span') {\n          const anchorBlock = this.getParent(startBlock)\n          const lang = ''\n          const preBlock = this.createBlock('pre', {\n            functionType: 'fencecode',\n            lang\n          })\n\n          const codeBlock = this.createBlock('code', {\n            lang\n          })\n\n          const inputBlock = this.createBlock('span', {\n            functionType: 'languageInput'\n          })\n\n          const codeContent = this.createBlock('span', {\n            text: startBlock.text,\n            lang,\n            functionType: 'codeContent'\n          })\n\n          this.appendChild(codeBlock, codeContent)\n          this.appendChild(preBlock, inputBlock)\n          this.appendChild(preBlock, codeBlock)\n          this.insertBefore(preBlock, anchorBlock)\n\n          this.removeBlock(anchorBlock)\n\n          const { key } = inputBlock\n          const offset = 0\n\n          this.cursor = {\n            start: { key, offset },\n            end: { key, offset }\n          }\n        } else {\n          this.cursor = {\n            start: this.cursor.start,\n            end: this.cursor.end\n          }\n        }\n      } else if (!hasFencedCodeBlockParent()) {\n        const { parent, startIndex, endIndex } = this.getCommonParent()\n        const children = parent ? parent.children : this.blocks\n        const referBlock = children[endIndex]\n        const lang = ''\n        const preBlock = this.createBlock('pre', {\n          functionType: 'fencecode',\n          lang\n        })\n        const codeBlock = this.createBlock('code', {\n          lang\n        })\n\n        const { isGitlabCompatibilityEnabled, listIndentation } = this\n        const markdown = new ExportMarkdown(\n          children.slice(startIndex, endIndex + 1),\n          listIndentation,\n          isGitlabCompatibilityEnabled\n        ).generate()\n        const codeContent = this.createBlock('span', {\n          text: markdown,\n          lang,\n          functionType: 'codeContent'\n        })\n        const inputBlock = this.createBlock('span', {\n          functionType: 'languageInput'\n        })\n        this.appendChild(codeBlock, codeContent)\n        this.appendChild(preBlock, inputBlock)\n        this.appendChild(preBlock, codeBlock)\n        this.insertAfter(preBlock, referBlock)\n        let i\n        const removeCache = []\n        for (i = startIndex; i <= endIndex; i++) {\n          const child = children[i]\n          removeCache.push(child)\n        }\n        removeCache.forEach(b => this.removeBlock(b))\n        const key = inputBlock.key\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n      }\n    }\n  }\n\n  ContentState.prototype.handleQuoteMenu = function (insertMode) {\n    const { start, end, affiliation } = this.selectionChange(this.cursor)\n    let startBlock = this.getBlock(start.key)\n    const isBlockQuote = affiliation.slice(0, 2).filter(b => /blockquote/.test(b.type))\n    // change blockquote to paragraph\n    if (isBlockQuote.length && !insertMode) {\n      const quoteBlock = isBlockQuote[0]\n      const children = quoteBlock.children\n      for (const child of children) {\n        this.insertBefore(child, quoteBlock)\n      }\n      this.removeBlock(quoteBlock)\n    // change paragraph to blockquote\n    } else {\n      if (start.key === end.key) {\n        if (startBlock.type === 'span') {\n          startBlock = this.getParent(startBlock)\n        }\n        const quoteBlock = this.createBlock('blockquote')\n        this.insertAfter(quoteBlock, startBlock)\n        this.removeBlock(startBlock)\n        this.appendChild(quoteBlock, startBlock)\n      } else {\n        const { parent, startIndex, endIndex } = this.getCommonParent()\n        const children = parent ? parent.children : this.blocks\n        const referBlock = children[endIndex]\n        const quoteBlock = this.createBlock('blockquote')\n\n        children.slice(startIndex, endIndex + 1).forEach(child => {\n          if (child !== referBlock) {\n            this.removeBlock(child, children)\n          } else {\n            this.insertAfter(quoteBlock, child)\n            this.removeBlock(child, children)\n          }\n          this.appendChild(quoteBlock, child)\n        })\n      }\n    }\n  }\n\n  ContentState.prototype.insertContainerBlock = function (functionType, block) {\n    const anchor = this.getAnchor(block)\n    if (!anchor) {\n      console.error('Can not find the anchor paragraph to insert paragraph')\n      return\n    }\n\n    const value = anchor.type === 'p'\n      ? anchor.children.map(child => child.text).join('\\n').trim()\n      : ''\n\n    const containerBlock = this.createContainerBlock(functionType, value)\n    this.insertAfter(containerBlock, anchor)\n    if (anchor.type === 'p') {\n      this.removeBlock(anchor)\n    }\n\n    const cursorBlock = containerBlock.children[0].children[0].children[0]\n    const { key } = cursorBlock\n    const offset = 0\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n  }\n\n  ContentState.prototype.showTablePicker = function () {\n    const { eventCenter } = this.muya\n    const reference = this.getPositionReference()\n\n    const handler = (rows, columns) => {\n      this.createTable({ rows: rows + 1, columns: columns + 1 })\n    }\n    eventCenter.dispatch('muya-table-picker', { row: -1, column: -1 }, reference, handler.bind(this))\n  }\n\n  ContentState.prototype.insertHtmlBlock = function (block) {\n    if (block.type === 'span') {\n      block = this.getParent(block)\n    }\n    const preBlock = this.initHtmlBlock(block)\n    const cursorBlock = this.firstInDescendant(preBlock)\n    const { key, text } = cursorBlock\n    const match = /^[^\\n]+\\n[^\\n]*/.exec(text)\n    const offset = match && match[0] ? match[0].length : 0\n\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n  }\n\n  ContentState.prototype.updateParagraph = function (paraType, insertMode = false) {\n    const { start, end } = this.cursor\n    const block = this.getBlock(start.key)\n    const { text, type } = block\n    let needDispatchChange = true\n\n    // Only allow valid transformations.\n    if (!this.isAllowedTransformation(block, paraType, start.key !== end.key)) {\n      return\n    }\n\n    // Convert back to paragraph.\n    if (paraType === 'reset-to-paragraph') {\n      const blockType = this.getTypeFromBlock(block)\n      if (!blockType) {\n        return\n      }\n\n      if (blockType === 'table') {\n        return\n      } else if (/heading|hr/.test(blockType)) {\n        paraType = 'paragraph'\n      } else {\n        paraType = blockType\n      }\n    }\n\n    switch (paraType) {\n      case 'front-matter': {\n        this.handleFrontMatter()\n        break\n      }\n      case 'ul-bullet':\n      case 'ul-task':\n      case 'ol-order': {\n        needDispatchChange = this.handleListMenu(paraType, insertMode)\n        break\n      }\n      case 'loose-list-item': {\n        this.handleLooseListItem()\n        break\n      }\n      case 'pre': {\n        this.handleCodeBlockMenu()\n        break\n      }\n      case 'blockquote': {\n        this.handleQuoteMenu(insertMode)\n        break\n      }\n      case 'mathblock': {\n        this.insertContainerBlock('multiplemath', block)\n        break\n      }\n      case 'table': {\n        this.showTablePicker()\n        break\n      }\n      case 'html': {\n        this.insertHtmlBlock(block)\n        break\n      }\n      case 'flowchart':\n      case 'sequence':\n      case 'mermaid':\n      case 'vega-lite':\n        this.insertContainerBlock(paraType, block)\n        break\n      case 'heading 1':\n      case 'heading 2':\n      case 'heading 3':\n      case 'heading 4':\n      case 'heading 5':\n      case 'heading 6':\n      case 'upgrade heading':\n      case 'degrade heading':\n      case 'paragraph': {\n        if (start.key !== end.key) {\n          return\n        }\n\n        const headingStyle = DEFAULT_TURNDOWN_CONFIG.headingStyle\n        const parent = this.getParent(block)\n        // \\u00A0 is &nbsp;\n        const [, hash, partText] = /(^ {0,3}#*[ \\u00A0]*)([\\s\\S]*)/.exec(text)\n        let newLevel = 0 // 1, 2, 3, 4, 5, 6\n        let newType = 'p'\n        let key\n\n        if (/\\d/.test(paraType)) {\n          newLevel = Number(paraType.split(/\\s/)[1])\n          newType = `h${newLevel}`\n        } else if (paraType === 'upgrade heading' || paraType === 'degrade heading') {\n          const currentLevel = getCurrentLevel(parent.type)\n          newLevel = currentLevel\n          if (paraType === 'upgrade heading' && currentLevel !== 1) {\n            if (currentLevel === 0) newLevel = 6\n            else newLevel = currentLevel - 1\n          } else if (paraType === 'degrade heading' && currentLevel !== 0) {\n            if (currentLevel === 6) newLevel = 0\n            else newLevel = currentLevel + 1\n          }\n          newType = newLevel === 0 ? 'p' : `h${newLevel}`\n        }\n\n        const startOffset = newLevel > 0\n          ? start.offset + newLevel - hash.length + 1\n          : start.offset - hash.length // no need to add `1`, because we didn't add `String.fromCharCode(160)` to text paragraph\n        const endOffset = newLevel > 0\n          ? end.offset + newLevel - hash.length + 1\n          : end.offset - hash.length\n        let newText = newLevel > 0\n          ? '#'.repeat(newLevel) + `${String.fromCharCode(160)}${partText}` // &nbsp; code: 160\n          : partText\n\n        // Remove <hr> content when converting to paragraph.\n        if (type === 'span' && block.functionType === 'thematicBreakLine') {\n          newText = ''\n        }\n\n        // No change\n        if (newType === 'p' && parent.type === newType) {\n          return\n        }\n        // No change\n        if (newType !== 'p' && parent.type === newType && parent.headingStyle === headingStyle) {\n          return\n        }\n\n        if (newType !== 'p') {\n          const header = this.createBlock(newType, {\n            headingStyle\n          })\n          const headerContent = this.createBlock('span', {\n            text: headingStyle === 'atx' ? newText.replace(/\\n/g, ' ') : newText,\n            functionType: headingStyle === 'atx' ? 'atxLine' : 'paragraphContent'\n          })\n          this.appendChild(header, headerContent)\n          key = headerContent.key\n\n          this.insertBefore(header, parent)\n          this.removeBlock(parent)\n        } else {\n          const pBlock = this.createBlockP(newText)\n          key = pBlock.children[0].key\n          this.insertAfter(pBlock, parent)\n          this.removeBlock(parent)\n        }\n\n        this.cursor = {\n          start: { key, offset: startOffset },\n          end: { key, offset: endOffset }\n        }\n        break\n      }\n      case 'hr': {\n        const pBlock = this.createBlockP()\n        const archor = block.type === 'span' ? this.getParent(block) : block\n        const hrBlock = this.createBlock('hr')\n        const thematicContent = this.createBlock('span', {\n          functionType: 'thematicBreakLine',\n          text: '---'\n        })\n        this.appendChild(hrBlock, thematicContent)\n        this.insertAfter(hrBlock, archor)\n        this.insertAfter(pBlock, hrBlock)\n        if (!text) {\n          if (block.type === 'span' && this.isOnlyChild(block)) {\n            this.removeBlock(archor)\n          } else {\n            this.removeBlock(block)\n          }\n        }\n        const { key } = pBlock.children[0]\n        const offset = 0\n        this.cursor = {\n          start: { key, offset },\n          end: { key, offset }\n        }\n        break\n      }\n    }\n    if (paraType === 'front-matter' || paraType === 'pre') {\n      this.render()\n    } else {\n      this.partialRender()\n    }\n\n    if (needDispatchChange) {\n      this.muya.dispatchSelectionChange()\n      this.muya.dispatchSelectionFormats()\n      this.muya.dispatchChange()\n    }\n  }\n\n  ContentState.prototype.insertParagraph = function (location, text = '', outMost = false) {\n    const { start, end } = this.cursor\n    // if cursor is not in one line or paragraph, can not insert paragraph\n    if (start.key !== end.key) return\n    const block = this.getBlock(start.key)\n    let anchor = null\n    if (outMost) {\n      anchor = this.findOutMostBlock(block)\n    } else {\n      anchor = this.getAnchor(block)\n    }\n\n    // You can not insert paragraph before frontmatter\n    if (!anchor || anchor && anchor.functionType === 'frontmatter' && location === 'before') {\n      return\n    }\n\n    const newBlock = this.createBlockP(text)\n    if (location === 'before') {\n      this.insertBefore(newBlock, anchor)\n    } else {\n      this.insertAfter(newBlock, anchor)\n    }\n    const { key } = newBlock.children[0]\n    const offset = text.length\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n    this.partialRender()\n    this.muya.eventCenter.dispatch('stateChange')\n  }\n\n  ContentState.prototype.getPreBlock = function (block) {\n    const { children } = block\n    if (!children || !children.length) return null\n    for (const child of children) {\n      if (child.type === 'pre') {\n        return child\n      } else {\n        return this.getPreBlock(child)\n      }\n    }\n    return null\n  }\n\n  // make a dulication of the current block\n  ContentState.prototype.duplicate = function () {\n    const { start, end } = this.cursor\n    const startOutmostBlock = this.findOutMostBlock(this.getBlock(start.key))\n    const endOutmostBlock = this.findOutMostBlock(this.getBlock(end.key))\n    if (startOutmostBlock !== endOutmostBlock) {\n      // if the cursor is not in one paragraph, just return\n      return\n    }\n    // if copied block has pre block: html, multiplemath, vega-light, mermaid, flowchart, sequence...\n    const copiedBlock = this.copyBlock(startOutmostBlock)\n    this.insertAfter(copiedBlock, startOutmostBlock)\n\n    const cursorBlock = this.firstInDescendant(copiedBlock)\n    // set cursor at the end of the first descendant of the duplicated block.\n    const { key, text } = cursorBlock\n    const offset = text.length\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n    this.partialRender()\n    return this.muya.eventCenter.dispatch('stateChange')\n  }\n\n  // delete current paragraph\n  ContentState.prototype.deleteParagraph = function (blockKey) {\n    let startOutmostBlock\n    if (blockKey) {\n      const block = this.getBlock(blockKey)\n      const firstEditableBlock = this.firstInDescendant(block)\n      startOutmostBlock = this.getAnchor(firstEditableBlock)\n    } else {\n      const { start, end } = this.cursor\n      startOutmostBlock = this.findOutMostBlock(this.getBlock(start.key))\n      const endOutmostBlock = this.findOutMostBlock(this.getBlock(end.key))\n      if (startOutmostBlock !== endOutmostBlock) {\n        // if the cursor is not in one paragraph, just return\n        return\n      }\n    }\n\n    const preBlock = this.getBlock(startOutmostBlock.preSibling)\n    const nextBlock = this.getBlock(startOutmostBlock.nextSibling)\n    let cursorBlock = null\n    if (nextBlock) {\n      cursorBlock = this.firstInDescendant(nextBlock)\n    } else if (preBlock) {\n      cursorBlock = this.lastInDescendant(preBlock)\n    } else {\n      const newBlock = this.createBlockP()\n      this.insertAfter(newBlock, startOutmostBlock)\n      cursorBlock = this.firstInDescendant(newBlock)\n    }\n    this.removeBlock(startOutmostBlock)\n    const { key, text } = cursorBlock\n    const offset = text.length\n    this.cursor = {\n      start: { key, offset },\n      end: { key, offset }\n    }\n    this.partialRender()\n    return this.muya.eventCenter.dispatch('stateChange')\n  }\n\n  ContentState.prototype.isSelectAll = function () {\n    const firstTextBlock = this.getFirstBlock()\n    const lastTextBlock = this.getLastBlock()\n    const { start, end } = this.cursor\n\n    return firstTextBlock.key === start.key &&\n      start.offset === 0 &&\n      lastTextBlock.key === end.key &&\n      end.offset === lastTextBlock.text.length &&\n      !this.muya.keyboard.isComposed\n  }\n\n  ContentState.prototype.selectAllContent = function () {\n    const firstTextBlock = this.getFirstBlock()\n    const lastTextBlock = this.getLastBlock()\n    this.cursor = {\n      start: {\n        key: firstTextBlock.key,\n        offset: 0\n      },\n      end: {\n        key: lastTextBlock.key,\n        offset: lastTextBlock.text.length\n      }\n    }\n\n    return this.render()\n  }\n\n  ContentState.prototype.selectAll = function () {\n    const mayBeCell = this.isSingleCellSelected()\n    const mayBeTable = this.isWholeTableSelected()\n\n    if (mayBeTable) {\n      this.selectedTableCells = null\n      return this.selectAllContent()\n    }\n\n    // Select whole table if already select one cell.\n    if (mayBeCell) {\n      const table = this.closest(mayBeCell, 'table')\n\n      if (table) {\n        return this.selectTable(table)\n      }\n    }\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    // handle selectAll in table.\n    if (startBlock.functionType === 'cellContent' && endBlock.functionType === 'cellContent') {\n      if (start.key === end.key) {\n        const table = this.closest(startBlock, 'table')\n        const cellBlock = this.closest(startBlock, /th|td/)\n\n        this.selectedTableCells = {\n          tableId: table.key,\n          row: 1,\n          column: 1,\n          cells: [{\n            key: cellBlock.key,\n            text: cellBlock.children[0].text,\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n          }]\n        }\n\n        this.singleRender(table, false)\n        return this.muya.eventCenter.dispatch('muya-format-picker', { reference: null })\n      } else {\n        const startTable = this.closest(startBlock, 'table')\n        const endTable = this.closest(endBlock, 'table')\n        // Check whether both blocks are in the same table.\n        if (!startTable || !endTable) {\n          console.error('No table found or invalid type.')\n          return\n        } else if (startTable.key !== endTable.key) {\n          // Select entire document\n          return\n        }\n        return this.selectTable(startTable)\n      }\n    }\n    // Handler selectAll in code block. only select all the code block conent.\n    // `code block` here is Math, HTML, BLOCK CODE, Mermaid, vega-lite, flowchart, front-matter etc...\n    if (startBlock.type === 'span' && startBlock.functionType === 'codeContent') {\n      const { key } = startBlock\n      this.cursor = {\n        start: {\n          key,\n          offset: 0\n        },\n        end: {\n          key,\n          offset: startBlock.text.length\n        }\n      }\n\n      return this.partialRender()\n    }\n    // Handler language input, only select language info only...\n    if (startBlock.type === 'span' && startBlock.functionType === 'languageInput') {\n      this.cursor = {\n        start: {\n          key: startBlock.key,\n          offset: 0\n        },\n        end: {\n          key: startBlock.key,\n          offset: startBlock.text.length\n        }\n      }\n      return this.partialRender()\n    }\n\n    return this.selectAllContent()\n  }\n\n  // Test whether the paragraph transformation is valid.\n  ContentState.prototype.isAllowedTransformation = function (block, toType, isMultilineSelection) {\n    const fromType = this.getTypeFromBlock(block)\n    if (toType === 'front-matter') {\n      // Front matter block is added at the beginning.\n      return true\n    } else if (!fromType) {\n      return false\n    } else if (isMultilineSelection && /heading|table/.test(toType)) {\n      return false\n    } else if (fromType === toType || toType === 'reset-to-paragraph') {\n      // Convert back to paragraph.\n      return true\n    }\n\n    switch (fromType) {\n      case 'ul-bullet':\n      case 'ul-task':\n      case 'ol-order':\n      case 'blockquote':\n      case 'paragraph': {\n        // Only allow line and table with an empty paragraph.\n        if (/hr|table/.test(toType) && block.text) {\n          return false\n        }\n        return true\n      }\n      case 'heading 1':\n      case 'heading 2':\n      case 'heading 3':\n      case 'heading 4':\n      case 'heading 5':\n      case 'heading 6':\n        return /paragraph|heading/.test(toType)\n      default:\n        // Tables and all code blocks are not allowed.\n        return false\n    }\n  }\n\n  // Translate block type into internal name.\n  ContentState.prototype.getTypeFromBlock = function (block) {\n    const { type } = block\n\n    let internalType = ''\n    const headingMatch = type.match(/^h([1-6]{1})$/)\n    if (headingMatch && headingMatch[1]) {\n      internalType = `heading ${headingMatch[1]}`\n    }\n\n    switch (type) {\n      case 'span': {\n        if (block.functionType === 'atxLine') {\n          internalType = 'heading 1' // loose match\n        } else if (block.functionType === 'languageInput') {\n          internalType = 'pre'\n        } else if (block.functionType === 'codeContent') {\n          if (block.lang === 'markup') {\n            internalType = 'html'\n          } else if (block.lang === 'latex') {\n            internalType = 'mathblock'\n          }\n\n          // We cannot easy distinguish between diagram and code blocks.\n          const rootBlock = this.getAnchor(block)\n          if (rootBlock && rootBlock.functionType !== 'fencecode') {\n            // Block seems to be a diagram block.\n            internalType = rootBlock.functionType\n          } else {\n            internalType = 'pre'\n          }\n        } else if (block.functionType === 'cellContent') {\n          internalType = 'table'\n        } else if (block.functionType === 'thematicBreakLine') {\n          internalType = 'hr'\n        }\n\n        // List and quote content is also a problem because it's shown as paragraph.\n        const { affiliation } = this.selectionChange(this.cursor)\n        const listTypes = affiliation\n          .slice(0, 3) // the third entry should be the ul/ol\n          .filter(b => /ul|ol/.test(b.type))\n          .map(b => b.listType)\n\n        // Prefer list or blockquote over paragraph.\n        if (listTypes && listTypes.length === 1) {\n          const listType = listTypes[0]\n          if (listType === 'bullet') {\n            internalType = 'ul-bullet'\n          } else if (listType === 'task') {\n            internalType = 'ul-task'\n          } if (listType === 'order') {\n            internalType = 'ol-order'\n          }\n        } else if (affiliation.length === 2 && affiliation[1].type === 'blockquote') {\n          internalType = 'blockquote'\n        } else if (block.functionType === 'paragraphContent') {\n          internalType = 'paragraph'\n        }\n        break\n      }\n      case 'div': {\n        // Preview for math formulas or diagramms.\n        return ''\n      }\n      case 'figure': {\n        if (block.functionType === 'multiplemath') {\n          internalType = 'mathblock'\n        } else {\n          internalType = block.functionType\n        }\n        break\n      }\n      case 'pre': {\n        if (block.functionType === 'multiplemath') {\n          internalType = 'mathblock'\n        } else if (block.functionType === 'fencecode' || block.functionType === 'indentcode') {\n          internalType = 'pre'\n        } else if (block.functionType === 'frontmatter') {\n          internalType = 'front-matter'\n        } else {\n          internalType = block.functionType\n        }\n        break\n      }\n      case 'ul': {\n        if (block.listType === 'task') {\n          internalType = 'ul-task'\n        } else {\n          internalType = 'ul-bullet'\n        }\n        break\n      }\n      case 'ol': {\n        internalType = 'ol-order'\n        break\n      }\n      case 'li': {\n        if (block.listItemType === 'order') {\n          internalType = 'ol-order'\n        } else if (block.listItemType === 'bullet') {\n          internalType = 'ul-bullet'\n        } else if (block.listItemType === 'task') {\n          internalType = 'ul-task'\n        }\n        break\n      }\n      case 'table':\n      case 'th':\n      case 'td': {\n        internalType = 'table'\n        break\n      }\n    }\n    return internalType\n  }\n}\n\nexport default paragraphCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\updateCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\searchCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\pasteCtrl.js",["557"],"\nimport { PARAGRAPH_TYPES, PREVIEW_DOMPURIFY_CONFIG, HAS_TEXT_BLOCK_REG, IMAGE_EXT_REG, URL_REG } from '../config'\nimport { sanitize, getUniqueId, getImageInfo as getImageSrc, getPageTitle } from '../utils'\nimport { getImageInfo } from '../utils/getImageInfo'\n\nconst LIST_REG = /ul|ol/\nconst LINE_BREAKS_REG = /\\n/\n\nconst pasteCtrl = ContentState => {\n  // check paste type: `MERGE` or `NEWLINE`\n  ContentState.prototype.checkPasteType = function (start, fragment) {\n    const fragmentType = fragment.type\n    const parent = this.getParent(start)\n\n    if (fragmentType === 'p') {\n      return 'MERGE'\n    } else if (/^h\\d/.test(fragmentType)) {\n      if (start.text) {\n        return 'MERGE'\n      } else {\n        return 'NEWLINE'\n      }\n    } else if (LIST_REG.test(fragmentType)) {\n      const listItem = this.getParent(parent)\n      const list = listItem && listItem.type === 'li' ? this.getParent(listItem) : null\n      if (list) {\n        if (\n          list.listType === fragment.listType &&\n          listItem.bulletMarkerOrDelimiter === fragment.children[0].bulletMarkerOrDelimiter\n        ) {\n          return 'MERGE'\n        } else {\n          return 'NEWLINE'\n        }\n      } else {\n        return 'NEWLINE'\n      }\n    } else {\n      return 'NEWLINE'\n    }\n  }\n\n  // Try to identify the data type.\n  ContentState.prototype.checkCopyType = function (html, text) {\n    let type = 'normal'\n    if (!html && text) {\n      type = 'copyAsMarkdown'\n      const match = /^<([a-zA-Z\\d-]+)(?=\\s|>).*?>[\\s\\S]+?<\\/([a-zA-Z\\d-]+)>$/.exec(text.trim())\n      if (match && match[1]) {\n        const tag = match[1]\n        if (tag === 'table' && match.length === 3 && match[2] === 'table') {\n          // Try to import a single table\n          const tmp = document.createElement('table')\n          tmp.innerHTML = text\n          if (tmp.childElementCount === 1) {\n            return 'htmlToMd'\n          }\n        }\n\n        // TODO: We could try to import HTML elements such as headings, text and lists to markdown for better UX.\n        type = PARAGRAPH_TYPES.find(type => type === tag) ? 'copyAsHtml' : type\n      }\n    }\n    return type\n  }\n\n  ContentState.prototype.standardizeHTML = async function (html) {\n    // Only extract the `body.innerHTML` when the `html` is a full HTML Document.\n    if (/<body>[\\s\\S]*<\\/body>/.test(html)) {\n      const match = /<body>([\\s\\S]*)<\\/body>/.exec(html)\n      if (match && typeof match[1] === 'string') {\n        html = match[1]\n      }\n    }\n\n    // Prevent XSS and sanitize HTML.\n    const { disableHtml } = this.muya.options\n    const sanitizedHtml = sanitize(html, PREVIEW_DOMPURIFY_CONFIG, disableHtml)\n    const tempWrapper = document.createElement('div')\n    tempWrapper.innerHTML = sanitizedHtml\n\n    // Special process for turndown.js, needed for Number app on macOS.\n    const tables = Array.from(tempWrapper.querySelectorAll('table'))\n    for (const table of tables) {\n      const row = table.querySelector('tr')\n      if (row.firstElementChild.tagName !== 'TH') {\n        [...row.children].forEach(cell => {\n          const th = document.createElement('th')\n          th.innerHTML = cell.innerHTML\n          cell.replaceWith(th)\n        })\n      }\n      const paragraphs = Array.from(table.querySelectorAll('p'))\n      for (const p of paragraphs) {\n        const span = document.createElement('span')\n        span.innerHTML = p.innerHTML\n        p.replaceWith(span)\n      }\n\n      const tds = table.querySelectorAll('td')\n      for (const td of tds) {\n        const rawHtml = td.innerHTML\n        if (/<br>/.test(rawHtml)) {\n          td.innerHTML = rawHtml.replace(/<br>/g, '&lt;br&gt;')\n        }\n      }\n    }\n\n    // Prevent it parse into a link if copy a url.\n    const links = Array.from(tempWrapper.querySelectorAll('a'))\n    for (const link of links) {\n      const href = link.getAttribute('href')\n      const text = link.textContent\n\n      if (href === text) {\n        const title = await getPageTitle(href)\n        if (title) {\n          link.textContent = title\n        } else {\n          const span = document.createElement('span')\n          span.innerHTML = text\n          link.replaceWith(span)\n        }\n      }\n    }\n    return tempWrapper.innerHTML\n  }\n\n  ContentState.prototype.pasteImage = async function (event) {\n    // Try to guess the clipboard file path.\n    const imagePath = this.muya.options.clipboardFilePath()\n    if (imagePath && typeof imagePath === 'string' && IMAGE_EXT_REG.test(imagePath)) {\n      const id = `loading-${getUniqueId()}`\n      if (this.selectedImage) {\n        this.replaceImage(this.selectedImage, {\n          alt: id,\n          src: imagePath\n        })\n      } else {\n        this.insertImage({\n          alt: id,\n          src: imagePath\n        })\n      }\n      const nSrc = await this.muya.options.imageAction(imagePath, id)\n      const { src } = getImageSrc(imagePath)\n      if (src) {\n        this.stateRender.urlMap.set(nSrc, src)\n      }\n\n      const imageWrapper = this.muya.container.querySelector(`span[data-id=${id}]`)\n\n      if (imageWrapper) {\n        const imageInfo = getImageInfo(imageWrapper)\n        this.replaceImage(imageInfo, {\n          src: nSrc\n        })\n      }\n      return imagePath\n    }\n\n    const items = event.clipboardData && event.clipboardData.items\n    let file = null\n    if (items && items.length) {\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].type.indexOf('image') !== -1) {\n          file = items[i].getAsFile()\n          break\n        }\n      }\n    }\n\n    // handle paste to create inline image\n    if (file) {\n      const id = `loading-${getUniqueId()}`\n      if (this.selectedImage) {\n        this.replaceImage(this.selectedImage, {\n          alt: id,\n          src: ''\n        })\n      } else {\n        this.insertImage({\n          alt: id,\n          src: ''\n        })\n      }\n\n      const reader = new FileReader()\n      reader.onload = event => {\n        const base64 = event.target.result\n        const imageWrapper = this.muya.container.querySelector(`span[data-id=${id}]`)\n        const imageContainer = this.muya.container.querySelector(`span[data-id=${id}] .ag-image-container`)\n        this.stateRender.urlMap.set(id, base64)\n        if (imageContainer) {\n          imageWrapper.classList.remove('ag-empty-image')\n          imageWrapper.classList.add('ag-image-success')\n          const image = document.createElement('img')\n          image.src = base64\n          imageContainer.appendChild(image)\n        }\n      }\n      reader.readAsDataURL(file)\n\n      const nSrc = await this.muya.options.imageAction(file, id)\n      const base64 = this.stateRender.urlMap.get(id)\n      if (base64) {\n        this.stateRender.urlMap.set(nSrc, base64)\n        this.stateRender.urlMap.delete(id)\n      }\n      const imageWrapper = this.muya.container.querySelector(`span[data-id=${id}]`)\n\n      if (imageWrapper) {\n        const imageInfo = getImageInfo(imageWrapper)\n        this.replaceImage(imageInfo, {\n          src: nSrc\n        })\n      }\n      return file\n    }\n    return null\n  }\n\n  // Handle global events.\n  ContentState.prototype.docPasteHandler = async function (event) {\n    // TODO: Pasting into CodeMirror will not work for special data like images\n    // or tables (HTML) because it's not handled.\n\n    const file = await this.pasteImage(event)\n    if (file) {\n      return event.preventDefault()\n    }\n\n    if (this.selectedTableCells) {\n      const { start } = this.cursor\n      const startBlock = this.getBlock(start.key)\n      const { selectedTableCells: stc } = this\n\n      // Exactly one table cell is selected. Replace the cells text via default handler.\n      if (startBlock && startBlock.functionType === 'cellContent' && stc.row === 1 && stc.column === 1) {\n        this.pasteHandler(event)\n        return event.preventDefault()\n      }\n    }\n  }\n\n  // Handle `normal` and `pasteAsPlainText` paste for preview mode.\n  ContentState.prototype.pasteHandler = async function (event, type = 'normal', rawText, rawHtml) {\n    event.preventDefault()\n    event.stopPropagation()\n\n    const text = rawText || event.clipboardData.getData('text/plain')\n    let html = rawHtml || event.clipboardData.getData('text/html')\n\n    // Support pasted URLs from Firefox.\n    if (URL_REG.test(text) && !/\\s/.test(text) && !html) {\n      html = `<a href=\"${text}\">${text}</a>`\n    }\n\n    // Remove crap from HTML such as meta data and styles.\n    html = await this.standardizeHTML(html)\n\n    let copyType = this.checkCopyType(html, text)\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    const parent = this.getParent(startBlock)\n\n    if (copyType === 'htmlToMd') {\n      html = text\n      copyType = 'normal'\n    }\n\n    if (start.key !== end.key) {\n      this.cutHandler()\n      return this.pasteHandler(event, type, rawText, rawHtml)\n    }\n\n    // NOTE: We should parse HTML if we can and use it instead the image (see GH#1271).\n    if (!html) {\n      const file = await this.pasteImage(event)\n      if (file) {\n        return\n      }\n    }\n\n    const appendHtml = (text) => {\n      startBlock.text = startBlock.text.substring(0, start.offset) + text + startBlock.text.substring(start.offset)\n      const { key } = start\n      const offset = start.offset + text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n    }\n\n    // Prepare paste\n    if (startBlock.type === 'span' && startBlock.functionType === 'languageInput') {\n      // Extract the first line from the language identifier (GH#553)\n      let language = text.trim().match(/^.*$/m)[0] || ''\n      const oldLanguageLength = startBlock.text.length\n      let offset = 0\n      if (start.offset !== 0 || end.offset !== oldLanguageLength) {\n        const prePartText = startBlock.text.substring(0, start.offset)\n        const postPartText = startBlock.text.substring(end.offset)\n\n        // Expect that the language doesn't contain new lines\n        language = prePartText + language + postPartText\n        offset = prePartText.length + language.length\n      } else {\n        offset = language.length\n      }\n\n      startBlock.text = language\n\n      const key = startBlock.key\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      // Hide code picker float box\n      const { eventCenter } = this.muya\n      eventCenter.dispatch('muya-code-picker', { reference: null })\n\n      // Update code block language and render\n      this.updateCodeLanguage(startBlock, language)\n      return\n    }\n\n    if (startBlock.type === 'span' && startBlock.functionType === 'codeContent') {\n      const blockText = startBlock.text\n      const prePartText = blockText.substring(0, start.offset)\n      const postPartText = blockText.substring(end.offset)\n      startBlock.text = prePartText + text + postPartText\n      const { key } = startBlock\n      const offset = start.offset + text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      return this.partialRender()\n    }\n\n    if (startBlock.functionType === 'cellContent') {\n      let isOneCellSelected = false\n      if (this.selectedTableCells) {\n        const { selectedTableCells: stc } = this\n        // Replace cells text when one cell is selected.\n        if (stc.row === 1 && stc.column === 1) {\n          isOneCellSelected = true\n        } else {\n          // Cancel event, multiple cells are selected.\n          return this.partialRender()\n        }\n      }\n\n      const { key } = startBlock\n      const pendingText = text.trim().replace(/\\n/g, '<br/>')\n      let offset = pendingText.length\n      if (isOneCellSelected) {\n        // Replace text and deselect cell.\n        startBlock.text = pendingText\n        this.selectedTableCells = null\n      } else {\n        offset += start.offset\n        startBlock.text = startBlock.text.substring(0, start.offset) + pendingText + startBlock.text.substring(end.offset)\n      }\n\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      return this.partialRender()\n    }\n\n    // Handle paste event and transform data into internal block structure.\n    if (copyType === 'copyAsHtml') {\n      switch (type) {\n        case 'normal': {\n          const htmlBlock = this.createBlockP(text.trim())\n          this.insertAfter(htmlBlock, parent)\n          this.removeBlock(parent)\n          // handler heading\n          this.insertHtmlBlock(htmlBlock)\n          break\n        }\n        case 'pasteAsPlainText': {\n          const lines = text.trim().split(LINE_BREAKS_REG)\n          let htmlBlock = null\n\n          if (!startBlock.text || lines.length > 1) {\n            htmlBlock = this.createBlockP((startBlock.text ? lines.slice(1) : lines).join('\\n'))\n          }\n          if (htmlBlock) {\n            this.insertAfter(htmlBlock, parent)\n            this.insertHtmlBlock(htmlBlock)\n          }\n          if (startBlock.text) {\n            appendHtml(lines[0])\n          } else {\n            this.removeBlock(parent)\n          }\n          break\n        }\n      }\n      return this.partialRender()\n    }\n\n    const stateFragments = type === 'pasteAsPlainText' || copyType === 'copyAsMarkdown'\n      ? this.markdownToState(text)\n      : this.html2State(html)\n\n    if (stateFragments.length <= 0) {\n      return\n    }\n\n    // Step 1: if select content, cut the content, and chop the block text into two part by the cursor.\n    const cacheText = endBlock.text.substring(end.offset)\n    startBlock.text = startBlock.text.substring(0, start.offset)\n\n    // Step 2: when insert the fragments, check begin a new block, or insert into pre block.\n    const firstFragment = stateFragments[0]\n    const tailFragments = stateFragments.slice(1)\n    const pasteType = this.checkPasteType(startBlock, firstFragment)\n\n    const getLastBlock = blocks => {\n      const len = blocks.length\n      const lastBlock = blocks[len - 1]\n\n      if (lastBlock.children.length === 0 && HAS_TEXT_BLOCK_REG.test(lastBlock.type)) {\n        return lastBlock\n      } else {\n        if (lastBlock.editable === false) {\n          return getLastBlock(blocks[len - 2].children)\n        } else {\n          return getLastBlock(lastBlock.children)\n        }\n      }\n    }\n\n    const lastBlock = getLastBlock(stateFragments)\n    let key = lastBlock.key\n    let offset = lastBlock.text.length\n    lastBlock.text += cacheText\n\n    switch (pasteType) {\n      case 'MERGE': {\n        if (LIST_REG.test(firstFragment.type)) {\n          const listItems = firstFragment.children\n          const firstListItem = listItems[0]\n          const liChildren = firstListItem.children\n          const originListItem = this.getParent(parent)\n          const originList = this.getParent(originListItem)\n          const targetListType = firstFragment.children[0].isLooseListItem\n          const originListType = originList.children[0].isLooseListItem\n          // No matter copy loose list to tight list or vice versa, the result is one loose list.\n          if (targetListType !== originListType) {\n            if (!targetListType) {\n              firstFragment.children.forEach(item => (item.isLooseListItem = true))\n            } else {\n              originList.children.forEach(item => (item.isLooseListItem = true))\n            }\n          }\n\n          if (liChildren[0].type === 'p') {\n            // TODO @JOCS\n            startBlock.text += liChildren[0].children[0].text\n            const tail = liChildren.slice(1)\n            if (tail.length) {\n              tail.forEach(t => {\n                this.appendChild(originListItem, t)\n              })\n            }\n            const firstFragmentTail = listItems.slice(1)\n            if (firstFragmentTail.length) {\n              firstFragmentTail.forEach(t => {\n                this.appendChild(originList, t)\n              })\n            }\n          } else {\n            listItems.forEach(c => {\n              this.appendChild(originList, c)\n            })\n          }\n          let target = originList\n          tailFragments.forEach(block => {\n            this.insertAfter(block, target)\n            target = block\n          })\n        } else if (firstFragment.type === 'p' || /^h\\d/.test(firstFragment.type)) {\n          const text = firstFragment.children[0].text\n          const lines = text.split('\\n')\n          let target = parent\n          if (parent.headingStyle === 'atx') {\n            startBlock.text += lines[0]\n            if (lines.length > 1) {\n              const pBlock = this.createBlockP(lines.slice(1).join('\\n'))\n              this.insertAfter(parent, pBlock)\n              target = pBlock\n            }\n          } else {\n            startBlock.text += text\n          }\n\n          tailFragments.forEach(block => {\n            this.insertAfter(block, target)\n            target = block\n          })\n        }\n        break\n      }\n      case 'NEWLINE': {\n        let target = parent\n        stateFragments.forEach(block => {\n          this.insertAfter(block, target)\n          target = block\n        })\n        if (startBlock.text.length === 0) {\n          this.removeBlock(parent)\n        }\n        break\n      }\n      default: {\n        throw new Error('unknown paste type')\n      }\n    }\n\n    // Step 3: set cursor and render\n    let cursorBlock = this.getBlock(key)\n    if (!cursorBlock) {\n      key = startBlock.key\n      offset = startBlock.text.length - cacheText.length\n      cursorBlock = startBlock\n    }\n\n    this.cursor = {\n      start: {\n        key, offset\n      },\n      end: {\n        key, offset\n      }\n    }\n    this.checkInlineUpdate(cursorBlock)\n    this.partialRender()\n    this.muya.dispatchSelectionChange()\n    this.muya.dispatchSelectionFormats()\n    return this.muya.dispatchChange()\n  }\n}\n\nexport default pasteCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\formatCtrl.js",["558","559","560","561","562","563","564","565","566"],"import selection from '../selection'\nimport { tokenizer, generator } from '../parser/'\nimport { FORMAT_MARKER_MAP, FORMAT_TYPES } from '../config'\nimport { getImageInfo } from '../utils/getImageInfo'\n\nconst getOffset = (offset, { range: { start, end }, type, tag, anchor, alt }) => {\n  const dis = offset - start\n  const len = end - start\n  switch (type) {\n    case 'strong':\n    case 'del':\n    case 'em':\n    case 'inline_code':\n    case 'inline_math': {\n      const MARKER_LEN = (type === 'strong' || type === 'del') ? 2 : 1\n      if (dis < 0) return 0\n      if (dis >= 0 && dis < MARKER_LEN) return -dis\n      if (dis >= MARKER_LEN && dis <= len - MARKER_LEN) return -MARKER_LEN\n      if (dis > len - MARKER_LEN && dis <= len) return len - dis - 2 * MARKER_LEN\n      if (dis > len) return -2 * MARKER_LEN\n      break\n    }\n    case 'html_tag': { // handle underline, sup, sub\n      const OPEN_MARKER_LEN = FORMAT_MARKER_MAP[tag].open.length\n      const CLOSE_MARKER_LEN = FORMAT_MARKER_MAP[tag].close.length\n      if (dis < 0) return 0\n      if (dis >= 0 && dis < OPEN_MARKER_LEN) return -dis\n      if (dis >= OPEN_MARKER_LEN && dis <= len - CLOSE_MARKER_LEN) return -OPEN_MARKER_LEN\n      if (dis > len - CLOSE_MARKER_LEN && dis <= len) return len - dis - OPEN_MARKER_LEN - CLOSE_MARKER_LEN\n      if (dis > len) return -OPEN_MARKER_LEN - CLOSE_MARKER_LEN\n      break\n    }\n    case 'link': {\n      const MARKER_LEN = 1\n      if (dis < MARKER_LEN) return 0\n      if (dis >= MARKER_LEN && dis <= MARKER_LEN + anchor.length) return -1\n      if (dis > MARKER_LEN + anchor.length) return anchor.length - dis\n      break\n    }\n    case 'image': {\n      const MARKER_LEN = 1\n      if (dis < MARKER_LEN) return 0\n      if (dis >= MARKER_LEN && dis < MARKER_LEN * 2) return -1\n      if (dis >= MARKER_LEN * 2 && dis <= MARKER_LEN * 2 + alt.length) return -2\n      if (dis > MARKER_LEN * 2 + alt.length) return alt.length - dis\n      break\n    }\n  }\n}\n\nconst clearFormat = (token, { start, end }) => {\n  if (start) {\n    const deltaStart = getOffset(start.offset, token)\n    start.delata += deltaStart\n  }\n  if (end) {\n    const delataEnd = getOffset(end.offset, token)\n    end.delata += delataEnd\n  }\n  switch (token.type) {\n    case 'strong':\n    case 'del':\n    case 'em':\n    case 'link':\n    case 'html_tag': { // underline, sub, sup\n      const { parent } = token\n      const index = parent.indexOf(token)\n      parent.splice(index, 1, ...token.children)\n      break\n    }\n    case 'image': {\n      token.type = 'text'\n      token.raw = token.alt\n      delete token.marker\n      delete token.src\n      break\n    }\n    case 'inline_math':\n    case 'inline_code': {\n      token.type = 'text'\n      token.raw = token.content\n      delete token.marker\n      break\n    }\n  }\n}\n\nconst addFormat = (type, block, { start, end }) => {\n  if (\n    block.type !== 'span' ||\n    (block.type === 'span' && !/paragraphContent|cellContent|atxLine/.test(block.functionType))\n  ) {\n    return false\n  }\n  switch (type) {\n    case 'em':\n    case 'del':\n    case 'inline_code':\n    case 'strong':\n    case 'inline_math': {\n      const MARKER = FORMAT_MARKER_MAP[type]\n      const oldText = block.text\n      block.text = oldText.substring(0, start.offset) +\n        MARKER + oldText.substring(start.offset, end.offset) +\n        MARKER + oldText.substring(end.offset)\n      start.offset += MARKER.length\n      end.offset += MARKER.length\n      break\n    }\n    case 'sub':\n    case 'sup':\n    case 'mark':\n    case 'u': {\n      const MARKER = FORMAT_MARKER_MAP[type]\n      const oldText = block.text\n      block.text = oldText.substring(0, start.offset) +\n        MARKER.open + oldText.substring(start.offset, end.offset) +\n        MARKER.close + oldText.substring(end.offset)\n      start.offset += MARKER.open.length\n      end.offset += MARKER.open.length\n      break\n    }\n    case 'link':\n    case 'image': {\n      const oldText = block.text\n      const anchorTextLen = end.offset - start.offset\n      block.text = oldText.substring(0, start.offset) +\n        (type === 'link' ? '[' : '![') +\n        oldText.substring(start.offset, end.offset) + ']()' +\n        oldText.substring(end.offset)\n      // put cursor between `()`\n      start.offset += type === 'link' ? 3 + anchorTextLen : 4 + anchorTextLen\n      end.offset = start.offset\n      break\n    }\n  }\n}\n\nconst checkTokenIsInlineFormat = token => {\n  const { type, tag } = token\n  if (FORMAT_TYPES.includes(type)) return true\n  if (type === 'html_tag' && /^(?:u|sub|sup|mark)$/i.test(tag)) return true\n  return false\n}\n\nconst formatCtrl = ContentState => {\n  ContentState.prototype.selectionFormats = function ({ start, end } = selection.getCursorRange()) {\n    if (!start || !end) {\n      return { formats: [], tokens: [], neighbors: [] }\n    }\n\n    const startBlock = this.getBlock(start.key)\n    const formats = []\n    const neighbors = []\n    let tokens = []\n    if (start.key === end.key) {\n      const { text } = startBlock\n      tokens = tokenizer(text, {\n        options: this.muya.options\n      })\n      ;(function iterator (tks) {\n        for (const token of tks) {\n          if (\n            checkTokenIsInlineFormat(token) &&\n            start.offset >= token.range.start &&\n            end.offset <= token.range.end\n          ) {\n            formats.push(token)\n          }\n          if (\n            checkTokenIsInlineFormat(token) &&\n            ((start.offset >= token.range.start && start.offset <= token.range.end) ||\n            (end.offset >= token.range.start && end.offset <= token.range.end) ||\n            (start.offset <= token.range.start && token.range.end <= end.offset))\n          ) {\n            neighbors.push(token)\n          }\n          if (token.children && token.children.length) {\n            iterator(token.children)\n          }\n        }\n      })(tokens)\n    }\n\n    return { formats, tokens, neighbors }\n  }\n\n  ContentState.prototype.clearBlockFormat = function (block, { start, end } = selection.getCursorRange(), type) {\n    if (!start || !end) {\n      return\n    }\n    if (block.type === 'pre') return false\n    const { key } = block\n    let tokens\n    let neighbors\n    if (start.key === end.key && start.key === key) {\n      ({ tokens, neighbors } = this.selectionFormats({ start, end }))\n    } else if (start.key !== end.key && start.key === key) {\n      ({ tokens, neighbors } = this.selectionFormats({ start, end: { key: start.key, offset: block.text.length } }))\n    } else if (start.key !== end.key && end.key === key) {\n      ({ tokens, neighbors } = this.selectionFormats({\n        start: {\n          key: end.key,\n          offset: 0\n        },\n        end\n      }))\n    } else {\n      ({ tokens, neighbors } = this.selectionFormats({\n        start: {\n          key,\n          offset: 0\n        },\n        end: {\n          key,\n          offset: block.text.length\n        }\n      }))\n    }\n\n    neighbors = type ? neighbors.filter(n => {\n      return n.type === type ||\n      n.type === 'html_tag' && n.tag === type\n    }) : neighbors\n\n    for (const neighbor of neighbors) {\n      clearFormat(neighbor, { start, end })\n    }\n    start.offset += start.delata\n    end.offset += end.delata\n    block.text = generator(tokens)\n  }\n\n  ContentState.prototype.format = function (type) {\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return\n    }\n\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    start.delata = end.delata = 0\n    if (start.key === end.key) {\n      const { formats, tokens, neighbors } = this.selectionFormats()\n      const currentFormats = formats.filter(format => {\n        return format.type === type ||\n          format.type === 'html_tag' && format.tag === type\n      }).reverse()\n      const currentNeightbors = neighbors.filter(format => {\n        return format.type === type ||\n        format.type === 'html_tag' && format.tag === type\n      }).reverse()\n      // cache delata\n      if (type === 'clear') {\n        for (const neighbor of neighbors) {\n          clearFormat(neighbor, { start, end })\n        }\n        start.offset += start.delata\n        end.offset += end.delata\n        startBlock.text = generator(tokens)\n      } else if (currentFormats.length) {\n        for (const token of currentFormats) {\n          clearFormat(token, { start, end })\n        }\n        start.offset += start.delata\n        end.offset += end.delata\n        startBlock.text = generator(tokens)\n      } else {\n        if (currentNeightbors.length) {\n          for (const neighbor of currentNeightbors) {\n            clearFormat(neighbor, { start, end })\n          }\n        }\n        start.offset += start.delata\n        end.offset += end.delata\n        startBlock.text = generator(tokens)\n        addFormat(type, startBlock, { start, end })\n        if (type === 'image') {\n          // Show image selector when create a inline image by menu/shortcut/or just input `![]()`\n          requestAnimationFrame(() => {\n            const startNode = selection.getSelectionStart()\n            if (startNode) {\n              const imageWrapper = startNode.closest('.ag-inline-image')\n              if (imageWrapper && imageWrapper.classList.contains('ag-empty-image')) {\n                const imageInfo = getImageInfo(imageWrapper)\n                this.muya.eventCenter.dispatch('muya-image-selector', {\n                  reference: imageWrapper,\n                  imageInfo,\n                  cb: () => {}\n                })\n              }\n            }\n          })\n        }\n      }\n      this.cursor = { start, end }\n      this.partialRender()\n    } else {\n      let nextBlock = startBlock\n      const formatType = type !== 'clear' ? type : undefined\n      while (nextBlock && nextBlock !== endBlock) {\n        this.clearBlockFormat(nextBlock, { start, end }, formatType)\n        nextBlock = this.findNextBlockInLocation(nextBlock)\n      }\n      this.clearBlockFormat(endBlock, { start, end }, formatType)\n\n      if (type !== 'clear') {\n        addFormat(type, startBlock, {\n          start,\n          end: { offset: startBlock.text.length }\n        })\n        nextBlock = this.findNextBlockInLocation(startBlock)\n        while (nextBlock && nextBlock !== endBlock) {\n          addFormat(type, nextBlock, {\n            start: { offset: 0 },\n            end: { offset: nextBlock.text.length }\n          })\n          nextBlock = this.findNextBlockInLocation(nextBlock)\n        }\n        addFormat(type, endBlock, {\n          start: { offset: 0 },\n          end\n        })\n      }\n\n      this.cursor = { start, end }\n      this.partialRender()\n    }\n  }\n}\n\nexport default formatCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tabCtrl.js",["567","568","569"],"import selection from '../selection'\nimport { HTML_TAGS, VOID_HTML_TAGS, HAS_TEXT_BLOCK_REG } from '../config'\nimport { tokenizer } from '../parser'\n\n/**\n * parseSelector\n * div#id.className => {tag: 'div', id: 'id', className: 'className', isVoid: false}\n */\n\nconst parseSelector = (str = '') => {\n  const REG_EXP = /(#|\\.)([^#.]+)/\n  let tag = ''\n  let id = ''\n  let className = ''\n  let isVoid = false\n  let cap\n  for (const tagName of HTML_TAGS) {\n    if (str.startsWith(tagName) && (!str[tagName.length] || /#|\\./.test(str[tagName.length]))) {\n      tag = tagName\n      if (VOID_HTML_TAGS.indexOf(tagName) > -1) isVoid = true\n      str = str.substring(tagName.length)\n    }\n  }\n  if (tag !== '') {\n    cap = REG_EXP.exec(str)\n    while (cap && str.length) {\n      if (cap[1] === '#') {\n        id = cap[2]\n      } else {\n        className = cap[2]\n      }\n      str = str.substring(cap[0].length)\n      cap = REG_EXP.exec(str)\n    }\n  }\n  return { tag, id, className, isVoid }\n}\n\nconst BOTH_SIDES_FORMATS = ['strong', 'em', 'inline_code', 'image', 'link', 'reference_image', 'reference_link', 'emoji', 'del', 'html_tag', 'inline_math']\n\nconst tabCtrl = ContentState => {\n  ContentState.prototype.findNextCell = function (block) {\n    if (block.functionType !== 'cellContent') {\n      throw new Error('only th and td can have next cell')\n    }\n    const cellBlock = this.getParent(block)\n    const nextSibling = this.getBlock(cellBlock.nextSibling)\n    const rowBlock = this.getBlock(cellBlock.parent)\n    const tbOrTh = this.getBlock(rowBlock.parent)\n    if (nextSibling) {\n      return this.firstInDescendant(nextSibling)\n    } else {\n      if (rowBlock.nextSibling) {\n        const nextRow = this.getBlock(rowBlock.nextSibling)\n        return this.firstInDescendant(nextRow)\n      } else if (tbOrTh.type === 'thead') {\n        const tBody = this.getBlock(tbOrTh.nextSibling)\n        if (tBody && tBody.children.length) {\n          return this.firstInDescendant(tBody)\n        }\n      }\n    }\n\n    return false\n  }\n\n  ContentState.prototype.findPreviousCell = function (block) {\n    if (block.functionType !== 'cellContent') {\n      throw new Error('only th and td can have previous cell')\n    }\n    const cellBlock = this.getParent(block)\n    const previousSibling = this.getBlock(cellBlock.preSibling)\n    const rowBlock = this.getBlock(cellBlock.parent)\n    const tbOrTh = this.getBlock(rowBlock.parent)\n    if (previousSibling) {\n      return this.firstInDescendant(previousSibling)\n    } else {\n      if (rowBlock.preSibling) {\n        const previousRow = this.getBlock(rowBlock.preSibling)\n        return this.lastInDescendant(previousRow)\n      } else if (tbOrTh.type === 'tbody') {\n        const tHead = this.getBlock(tbOrTh.preSibling)\n        if (tHead && tHead.children.length) {\n          return this.lastInDescendant(tHead)\n        }\n      }\n    }\n    return block\n  }\n\n  ContentState.prototype.isUnindentableListItem = function (block) {\n    const parent = this.getParent(block)\n    const listItem = this.getParent(parent)\n    const list = this.getParent(listItem)\n    const listParent = this.getParent(list)\n    if (!this.isCollapse()) return false\n    if (listParent && listParent.type === 'li') {\n      return !list.preSibling ? 'REPLACEMENT' : 'INDENT'\n    }\n    return false\n  }\n\n  ContentState.prototype.isIndentableListItem = function () {\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const parent = this.getParent(startBlock)\n    if (parent.type !== 'p' || !parent.parent) {\n      return false\n    }\n\n    const listItem = this.getParent(parent)\n    if (listItem.type !== 'li' || start.key !== end.key || start.offset !== end.offset) {\n      return false\n    }\n\n    // Now we know it's a list item. Check whether we can indent the list item.\n    const list = this.getParent(listItem)\n    return list && /ol|ul/.test(list.type) && listItem.preSibling\n  }\n\n  ContentState.prototype.unindentListItem = function (block, type) {\n    const pBlock = this.getParent(block)\n    const listItem = this.getParent(pBlock)\n    const list = this.getParent(listItem)\n    const listParent = this.getParent(list)\n    if (type === 'REPLACEMENT') {\n      this.insertBefore(pBlock, list)\n      if (this.isOnlyChild(listItem)) {\n        this.removeBlock(list)\n      } else {\n        this.removeBlock(listItem)\n      }\n    } else if (type === 'INDENT') {\n      if (list.children.length === 1) {\n        this.removeBlock(list)\n      } else {\n        const newList = this.createBlock(list.type)\n        let target = this.getNextSibling(listItem)\n        while (target) {\n          this.appendChild(newList, target)\n          const temp = target\n          target = this.getNextSibling(target)\n          this.removeBlock(temp, list)\n        }\n\n        if (newList.children.length) this.appendChild(listItem, newList)\n        this.removeBlock(listItem, list)\n        if (!list.children.length) {\n          this.removeBlock(list)\n        }\n      }\n      this.insertAfter(listItem, listParent)\n      let target = this.getNextSibling(list)\n      while (target) {\n        this.appendChild(listItem, target)\n        this.removeBlock(target, listParent)\n        target = this.getNextSibling(target)\n      }\n    }\n\n    return this.partialRender()\n  }\n\n  ContentState.prototype.indentListItem = function () {\n    const { start } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const parent = this.getParent(startBlock)\n    const listItem = this.getParent(parent)\n    const list = this.getParent(listItem)\n    const prevListItem = this.getPreSibling(listItem)\n\n    this.removeBlock(listItem)\n\n    // Search for a list in previous block\n    let newList = this.getLastChild(prevListItem)\n    if (!newList || !/ol|ul/.test(newList.type)) {\n      newList = this.createBlock(list.type)\n      this.appendChild(prevListItem, newList)\n    }\n\n    // Update item type only if we insert into an existing list\n    if (newList.children.length !== 0) {\n      listItem.isLooseListItem = newList.children[0].isLooseListItem\n    }\n\n    this.appendChild(newList, listItem)\n    return this.partialRender()\n  }\n\n  ContentState.prototype.insertTab = function () {\n    const tabSize = this.tabSize\n    const tabCharacter = String.fromCharCode(160).repeat(tabSize)\n    const { start, end } = this.cursor\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n    if (start.key === end.key && start.offset === end.offset) {\n      startBlock.text = startBlock.text.substring(0, start.offset) +\n        tabCharacter + endBlock.text.substring(end.offset)\n      const key = start.key\n      const offset = start.offset + tabCharacter.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      return this.partialRender()\n    }\n  }\n\n  ContentState.prototype.checkCursorAtEndFormat = function (text, offset) {\n    const { labels } = this.stateRender\n    const tokens = tokenizer(text, {\n      hasBeginRules: false,\n      labels,\n      options: this.muya.options\n    })\n    let result = null\n    const walkTokens = tkns => {\n      for (const token of tkns) {\n        const { marker, type, range, children, srcAndTitle, hrefAndTitle, backlash, closeTag, isFullLink, label } = token\n        const { start, end } = range\n        if (BOTH_SIDES_FORMATS.includes(type) && offset > start && offset < end) {\n          switch (type) {\n            case 'strong':\n            case 'em':\n            case 'inline_code':\n            case 'emoji':\n            case 'del':\n            case 'inline_math': {\n              if (marker && offset === end - marker.length) {\n                result = {\n                  offset: marker.length\n                }\n                return\n              }\n              break\n            }\n            case 'image':\n            case 'link': {\n              const linkTitleLen = (srcAndTitle || hrefAndTitle).length\n              const secondLashLen = backlash && backlash.second ? backlash.second.length : 0\n              if (offset === end - 3 - (linkTitleLen + secondLashLen)) {\n                result = {\n                  offset: 2\n                }\n                return\n              } else if (offset === end - 1) {\n                result = {\n                  offset: 1\n                }\n                return\n              }\n              break\n            }\n            case 'reference_image':\n            case 'reference_link': {\n              const labelLen = label ? label.length : 0\n              const secondLashLen = backlash && backlash.second ? backlash.second.length : 0\n              if (isFullLink) {\n                if (offset === end - 3 - labelLen - secondLashLen) {\n                  result = {\n                    offset: 2\n                  }\n                  return\n                } else if (offset === end - 1) {\n                  result = {\n                    offset: 1\n                  }\n                  return\n                }\n              } else if (offset === end - 1) {\n                result = {\n                  offset: 1\n                }\n                return\n              }\n              break\n            }\n            case 'html_tag': {\n              if (closeTag && offset === end - closeTag.length) {\n                result = {\n                  offset: closeTag.length\n                }\n                return\n              }\n              break\n            }\n            default:\n              break\n          }\n        }\n        if (children && children.length) {\n          walkTokens(children)\n        }\n      }\n    }\n    walkTokens(tokens)\n\n    return result\n  }\n\n  ContentState.prototype.tabHandler = function (event) {\n    // disable tab focus\n    event.preventDefault()\n\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return\n    }\n    const startBlock = this.getBlock(start.key)\n    const endBlock = this.getBlock(end.key)\n\n    if (event.shiftKey && !startBlock.functionType === 'cellContent') {\n      const unindentType = this.isUnindentableListItem(startBlock)\n      if (unindentType) {\n        this.unindentListItem(startBlock, unindentType)\n      }\n      return\n    }\n\n    // Handle `tab` to jump to the end of format when the cursor is at the end of format content.\n    if (\n      start.key === end.key &&\n      start.offset === end.offset &&\n      HAS_TEXT_BLOCK_REG.test(startBlock.type) &&\n      startBlock.functionType !== 'codeContent' && // code content has no inline syntax\n      startBlock.functionType !== 'languageInput' // language input textarea has no inline syntax\n    ) {\n      const { text, key } = startBlock\n      const { offset } = start\n      const atEnd = this.checkCursorAtEndFormat(text, offset)\n      if (atEnd) {\n        this.cursor = {\n          start: { key, offset: offset + atEnd.offset },\n          end: { key, offset: offset + atEnd.offset }\n        }\n        return this.partialRender()\n      }\n    }\n\n    // Auto-complete of inline html tag and html block and `html` code block.\n    if (\n      start.key === end.key &&\n      start.offset === end.offset &&\n      startBlock.type === 'span' &&\n      (!startBlock.functionType || startBlock.functionType === 'codeContent' && /markup|html|xml|svg|mathml/.test(startBlock.lang))\n    ) {\n      const { text } = startBlock\n      const lastWordBeforeCursor = text.substring(0, start.offset).split(/\\s+/).pop()\n      const { tag, isVoid, id, className } = parseSelector(lastWordBeforeCursor)\n\n      if (tag) {\n        const preText = text.substring(0, start.offset - lastWordBeforeCursor.length)\n        const postText = text.substring(end.offset)\n        if (!tag) return\n        let html = `<${tag}`\n        const key = startBlock.key\n        let startOffset = 0\n        let endOffset = 0\n        switch (tag) {\n          case 'img':\n            html += ' alt=\"\" src=\"\"'\n            startOffset = endOffset = html.length - 1\n            break\n          case 'input':\n            html += ' type=\"text\"'\n            startOffset = html.length - 5\n            endOffset = html.length - 1\n            break\n          case 'a':\n            html += ' href=\"\"'\n            startOffset = endOffset = html.length - 1\n            break\n          case 'link':\n            html += ' rel=\"stylesheet\" href=\"\"'\n            startOffset = endOffset = html.length - 1\n            break\n        }\n        if (id) {\n          html += ` id=\"${id}\"`\n        }\n        if (className) {\n          html += ` class=\"${className}\"`\n        }\n        html += '>'\n        if (startOffset === 0 && endOffset === 0) {\n          startOffset = endOffset = html.length\n        }\n        if (!isVoid) {\n          html += `</${tag}>`\n        }\n        startBlock.text = preText + html + postText\n        this.cursor = {\n          start: { key, offset: startOffset + preText.length },\n          end: { key, offset: endOffset + preText.length }\n        }\n        return this.partialRender()\n      }\n    }\n\n    // Handle `tab` key in table cell.\n    let nextCell\n    if (start.key === end.key && startBlock.functionType === 'cellContent') {\n      nextCell = event.shiftKey\n        ? this.findPreviousCell(startBlock)\n        : this.findNextCell(startBlock)\n    } else if (endBlock.functionType === 'cellContent') {\n      nextCell = endBlock\n    }\n    if (nextCell) {\n      const { key } = nextCell\n\n      const offset = 0\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n\n      const figure = this.closest(nextCell, 'figure')\n      return this.singleRender(figure)\n    }\n\n    if (this.isIndentableListItem()) {\n      return this.indentListItem()\n    }\n    return this.insertTab()\n  }\n}\n\nexport default tabCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\containerCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\tocCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\imageCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\htmlBlock.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\codeBlockCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\inputCtrl.js",["570","571"],"import selection from '../selection'\nimport { getTextContent } from '../selection/dom'\nimport { beginRules } from '../parser/rules'\nimport { tokenizer } from '../parser/'\nimport { CLASS_OR_ID } from '../config'\n\nconst BRACKET_HASH = {\n  '{': '}',\n  '[': ']',\n  '(': ')',\n  '*': '*',\n  _: '_',\n  '\"': '\"',\n  '\\'': '\\'',\n  $: '$',\n  '~': '~'\n}\n\nconst BACK_HASH = {\n  '}': '{',\n  ']': '[',\n  ')': '(',\n  '*': '*',\n  _: '_',\n  '\"': '\"',\n  '\\'': '\\'',\n  $: '$',\n  '~': '~'\n}\n\n// TODO: refactor later.\nlet renderCodeBlockTimer = null\n\nconst inputCtrl = ContentState => {\n  // Input @ to quick insert paragraph\n  ContentState.prototype.checkQuickInsert = function (block) {\n    const { type, text, functionType } = block\n    if (type !== 'span' || functionType !== 'paragraphContent') return false\n    return /^@\\S*$/.test(text)\n  }\n\n  ContentState.prototype.checkCursorInTokenType = function (functionType, text, offset, type) {\n    if (!/atxLine|paragraphContent|cellContent/.test(functionType)) {\n      return false\n    }\n\n    const tokens = tokenizer(text, {\n      hasBeginRules: false,\n      options: this.muya.options\n    })\n    return tokens.filter(t => t.type === type).some(t => offset >= t.range.start && offset <= t.range.end)\n  }\n\n  ContentState.prototype.checkNotSameToken = function (functionType, oldText, text) {\n    if (!/atxLine|paragraphContent|cellContent/.test(functionType)) {\n      return false\n    }\n\n    const oldTokens = tokenizer(oldText, {\n      options: this.muya.options\n    })\n    const tokens = tokenizer(text, {\n      options: this.muya.options\n    })\n\n    const oldCache = {}\n    const cache = {}\n\n    for (const { type } of oldTokens) {\n      if (oldCache[type]) {\n        oldCache[type]++\n      } else {\n        oldCache[type] = 1\n      }\n    }\n\n    for (const { type } of tokens) {\n      if (cache[type]) {\n        cache[type]++\n      } else {\n        cache[type] = 1\n      }\n    }\n\n    if (Object.keys(oldCache).length !== Object.keys(cache).length) {\n      return true\n    }\n\n    for (const key of Object.keys(oldCache)) {\n      if (!cache[key] || oldCache[key] !== cache[key]) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  ContentState.prototype.inputHandler = function (event, notEqual = false) {\n    const { start, end } = selection.getCursorRange()\n    if (!start || !end) {\n      return\n    }\n    const { start: oldStart, end: oldEnd } = this.cursor\n    const key = start.key\n    const block = this.getBlock(key)\n    const paragraph = document.querySelector(`#${key}`)\n\n    // Fix issue 1447\n    // Fixme: any better solution?\n    if (\n      oldStart.key === oldEnd.key &&\n      oldStart.offset === oldEnd.offset &&\n      block.text.endsWith('\\n') &&\n      oldStart.offset === block.text.length &&\n      event.inputType === 'insertText'\n    ) {\n      event.preventDefault()\n      block.text += event.data\n      const offset = block.text.length\n      this.cursor = {\n        start: { key, offset },\n        end: { key, offset }\n      }\n      this.singleRender(block)\n      return this.inputHandler(event, true)\n    }\n\n    let text = getTextContent(paragraph, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER])\n\n    let needRender = false\n    let needRenderAll = false\n    if (oldStart.key !== oldEnd.key) {\n      const startBlock = this.getBlock(oldStart.key)\n      const startOutmostBlock = this.findOutMostBlock(startBlock)\n      const endBlock = this.getBlock(oldEnd.key)\n      const endOutmostBlock = this.findOutMostBlock(endBlock)\n      if (\n        // fix #918.\n        startBlock.functionType === 'languageInput'\n      ) {\n        if (startOutmostBlock === endOutmostBlock && !endBlock.nextSibling) {\n          this.removeBlocks(startBlock, endBlock, false)\n          endBlock.text = ''\n        } else if (startOutmostBlock !== endOutmostBlock) {\n          const preBlock = this.getParent(startBlock)\n          const pBlock = this.createBlock('p')\n          this.removeBlocks(startBlock, endBlock)\n          startBlock.functionType = 'paragraphContent'\n          this.appendChild(pBlock, startBlock)\n          this.insertBefore(pBlock, preBlock)\n          this.removeBlock(preBlock)\n        } else {\n          this.removeBlocks(startBlock, endBlock)\n        }\n      } else {\n        this.removeBlocks(startBlock, endBlock)\n      }\n      if (this.blocks.length === 1) {\n        needRenderAll = true\n      }\n      needRender = true\n    }\n\n    // auto pair (not need to auto pair in math block)\n    if (block && (block.text !== text || notEqual)) {\n      if (\n        start.key === end.key &&\n        start.offset === end.offset &&\n        event.type === 'input'\n      ) {\n        const { offset } = start\n        const { autoPairBracket, autoPairMarkdownSyntax, autoPairQuote } = this.muya.options\n        const inputChar = text.charAt(+offset - 1)\n        const preInputChar = text.charAt(+offset - 2)\n        const prePreInputChar = text.charAt(+offset - 3)\n        const postInputChar = text.charAt(+offset)\n\n        if (/^delete/.test(event.inputType)) {\n          // handle `deleteContentBackward` or `deleteContentForward`\n          const deletedChar = block.text[offset]\n          if (event.inputType === 'deleteContentBackward' && postInputChar === BRACKET_HASH[deletedChar]) {\n            needRender = true\n            text = text.substring(0, offset) + text.substring(offset + 1)\n          }\n          if (event.inputType === 'deleteContentForward' && inputChar === BACK_HASH[deletedChar]) {\n            needRender = true\n            start.offset -= 1\n            end.offset -= 1\n            text = text.substring(0, offset - 1) + text.substring(offset)\n          }\n          /* eslint-disable no-useless-escape */\n        } else if (\n          (event.inputType.indexOf('delete') === -1) &&\n          (inputChar === postInputChar) &&\n          (\n            (autoPairQuote && /[']{1}/.test(inputChar)) ||\n            (autoPairQuote && /[\"]{1}/.test(inputChar)) ||\n            (autoPairBracket && /[\\}\\]\\)]{1}/.test(inputChar)) ||\n            (autoPairMarkdownSyntax && /[$]{1}/.test(inputChar)) ||\n            (autoPairMarkdownSyntax && /[*$`~_]{1}/.test(inputChar)) && /[_*~]{1}/.test(prePreInputChar)\n          )\n        ) {\n          needRender = true\n          text = text.substring(0, offset) + text.substring(offset + 1)\n        } else {\n          /* eslint-disable no-useless-escape */\n          // Not Unicode aware, since things like \\p{Alphabetic} or \\p{L} are not supported yet\n          const isInInlineMath = this.checkCursorInTokenType(block.functionType, text, offset, 'inline_math')\n          const isInInlineCode = this.checkCursorInTokenType(block.functionType, text, offset, 'inline_code')\n          if (\n            !/\\\\/.test(preInputChar) &&\n            ((autoPairQuote && /[']{1}/.test(inputChar) && !(/[a-zA-Z\\d]{1}/.test(preInputChar))) ||\n            (autoPairQuote && /[\"]{1}/.test(inputChar)) ||\n            (autoPairBracket && /[\\{\\[\\(]{1}/.test(inputChar)) ||\n            (block.functionType !== 'codeContent' && !isInInlineMath && !isInInlineCode && autoPairMarkdownSyntax && /[*$`~_]{1}/.test(inputChar)))\n          ) {\n            needRender = true\n            text = BRACKET_HASH[event.data]\n              ? text.substring(0, offset) + BRACKET_HASH[inputChar] + text.substring(offset)\n              : text\n          }\n          /* eslint-enable no-useless-escape */\n          // Delete the last `*` of `**` when you insert one space between `**` to create a bullet list.\n          if (\n            /\\s/.test(event.data) &&\n            /^\\* /.test(text) &&\n            preInputChar === '*' &&\n            postInputChar === '*'\n          ) {\n            text = text.substring(0, offset) + text.substring(offset + 1)\n            needRender = true\n          }\n        }\n      }\n\n      if (this.checkNotSameToken(block.functionType, block.text, text)) {\n        needRender = true\n      }\n      // Just work for `Shift + Enter` to create a soft and hard line break.\n      if (\n        block.text.endsWith('\\n') &&\n        start.offset === text.length &&\n        (event.inputType === 'insertText' || event.type === 'compositionend')\n      ) {\n        block.text += event.data\n        start.offset++\n        end.offset++\n      } else if (\n        block.text.length === oldStart.offset &&\n        block.text[oldStart.offset - 2] === '\\n' &&\n        event.inputType === 'deleteContentBackward'\n      ) {\n        block.text = block.text.substring(0, oldStart.offset - 1)\n        start.offset = block.text.length\n        end.offset = block.text.length\n      } else {\n        block.text = text\n      }\n\n      // Update code block language when modify code block identifer\n      if (block.functionType === 'languageInput') {\n        const parent = this.getParent(block)\n        parent.lang = block.text\n      }\n\n      if (beginRules.reference_definition.test(text)) {\n        needRenderAll = true\n      }\n    }\n\n    // show quick insert\n    const rect = paragraph.getBoundingClientRect()\n    const checkQuickInsert = this.checkQuickInsert(block)\n    const reference = this.getPositionReference()\n    reference.getBoundingClientRect = function () {\n      const { x, y, left, top, height, bottom } = rect\n\n      return Object.assign({}, {\n        left,\n        x,\n        top,\n        y,\n        bottom,\n        height,\n        width: 0,\n        right: left\n      })\n    }\n\n    this.muya.eventCenter.dispatch('muya-quick-insert', reference, block, !!checkQuickInsert)\n\n    this.cursor = { start, end }\n\n    // Throttle render if edit in code block.\n    if (block && block.type === 'span' && block.functionType === 'codeContent') {\n      if (renderCodeBlockTimer) {\n        clearTimeout(renderCodeBlockTimer)\n      }\n      if (needRender) {\n        this.partialRender()\n      } else {\n        renderCodeBlockTimer = setTimeout(() => {\n          this.partialRender()\n        }, 300)\n      }\n      return\n    }\n\n    const checkMarkedUpdate = /atxLine|paragraphContent|cellContent/.test(block.functionType) ? this.checkNeedRender() : false\n    let inlineUpdatedBlock = null\n    if (/atxLine|paragraphContent|cellContent|thematicBreakLine/.test(block.functionType)) {\n      inlineUpdatedBlock = this.isCollapse() && this.checkInlineUpdate(block)\n    }\n\n    // just for fix #707,need render All if in combines pre list and next list into one list.\n    if (inlineUpdatedBlock) {\n      const liBlock = this.getParent(inlineUpdatedBlock)\n      if (liBlock && liBlock.type === 'li' && liBlock.preSibling && liBlock.nextSibling) {\n        needRenderAll = true\n      }\n    }\n\n    if (checkMarkedUpdate || inlineUpdatedBlock || needRender) {\n      return needRenderAll ? this.render() : this.partialRender()\n    }\n  }\n}\n\nexport default inputCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\emojiCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\clickCtrl.js",["572"],"import selection from '../selection'\nimport { isMuyaEditorElement } from '../selection/dom'\nimport { HAS_TEXT_BLOCK_REG, CLASS_OR_ID } from '../config'\nimport { getParentCheckBox } from '../utils/getParentCheckBox'\nimport { cumputeCheckboxStatus } from '../utils/cumputeCheckBoxStatus'\n\nconst clickCtrl = ContentState => {\n  ContentState.prototype.clickHandler = function (event) {\n    const { eventCenter } = this.muya\n    const { target } = event\n    if (isMuyaEditorElement(target)) {\n      const lastBlock = this.getLastBlock()\n      const archor = this.findOutMostBlock(lastBlock)\n      const archorParagraph = document.querySelector(`#${archor.key}`)\n      const rect = archorParagraph.getBoundingClientRect()\n      // If click below the last paragraph\n      // and the last paragraph is not empty, create a new empty paragraph\n      if (event.clientY > rect.top + rect.height) {\n        let needToInsertNewParagraph = false\n        if (lastBlock.type === 'span') {\n          if (/atxLine|paragraphContent/.test(lastBlock.functionType) && /\\S/.test(lastBlock.text)) {\n            needToInsertNewParagraph = true\n          }\n          if (!/atxLine|paragraphContent/.test(lastBlock.functionType)) {\n            needToInsertNewParagraph = true\n          }\n        } else {\n          needToInsertNewParagraph = true\n        }\n\n        if (needToInsertNewParagraph) {\n          event.preventDefault()\n          const paragraphBlock = this.createBlockP()\n          this.insertAfter(paragraphBlock, archor)\n          const key = paragraphBlock.children[0].key\n          const offset = 0\n          this.cursor = {\n            start: { key, offset },\n            end: { key, offset }\n          }\n\n          return this.render()\n        }\n      }\n    }\n    // handle front menu click\n    const { start: oldStart, end: oldEnd } = this.cursor\n    if (oldStart && oldEnd) {\n      let hasSameParent = false\n      const startBlock = this.getBlock(oldStart.key)\n      const endBlock = this.getBlock(oldEnd.key)\n      if (startBlock && endBlock) {\n        const startOutBlock = this.findOutMostBlock(startBlock)\n        const endOutBlock = this.findOutMostBlock(endBlock)\n        hasSameParent = startOutBlock === endOutBlock\n      }\n      // show the muya-front-menu only when the cursor in the same paragraph\n      if (target.closest('.ag-front-icon') && hasSameParent) {\n        const currentBlock = this.findOutMostBlock(startBlock)\n        const frontIcon = target.closest('.ag-front-icon')\n        const rect = frontIcon.getBoundingClientRect()\n        const reference = {\n          getBoundingClientRect () {\n            return rect\n          },\n          clientWidth: rect.width,\n          clientHeight: rect.height,\n          id: currentBlock.key\n        }\n        this.selectedBlock = currentBlock\n        eventCenter.dispatch('muya-front-menu', { reference, outmostBlock: currentBlock, startBlock, endBlock })\n        return this.partialRender()\n      }\n    }\n    const { start, end } = selection.getCursorRange()\n    // fix #625, the selection maybe not in edit area.\n    if (!start || !end) {\n      return\n    }\n    // format-click\n    const node = selection.getSelectionStart()\n    const inlineNode = node ? node.closest('.ag-inline-rule') : null\n\n    // link-format-click\n    let parentNode = inlineNode\n    while (parentNode !== null && parentNode.classList.contains(CLASS_OR_ID.AG_INLINE_RULE)) {\n      if (parentNode.tagName === 'A') {\n        const formatType = 'link' // auto link or []() link\n        const data = {\n          text: inlineNode.textContent,\n          href: parentNode.getAttribute('href')\n        }\n        eventCenter.dispatch('format-click', {\n          event,\n          formatType,\n          data\n        })\n        break\n      } else {\n        parentNode = parentNode.parentNode\n      }\n    }\n\n    if (inlineNode) {\n      let formatType = null\n      let data = null\n      switch (inlineNode.tagName) {\n        case 'SPAN': {\n          if (inlineNode.hasAttribute('data-emoji')) {\n            formatType = 'emoji'\n            data = inlineNode.getAttribute('data-emoji')\n          } else if (inlineNode.classList.contains('ag-math-text')) {\n            formatType = 'inline_math'\n            data = inlineNode.textContent\n          }\n          break\n        }\n        case 'STRONG': {\n          formatType = 'strong'\n          data = inlineNode.textContent\n          break\n        }\n        case 'EM': {\n          formatType = 'em'\n          data = inlineNode.textContent\n          break\n        }\n        case 'DEL': {\n          formatType = 'del'\n          data = inlineNode.textContent\n          break\n        }\n        case 'CODE': {\n          formatType = 'inline_code'\n          data = inlineNode.textContent\n          break\n        }\n      }\n      if (formatType) {\n        eventCenter.dispatch('format-click', {\n          event,\n          formatType,\n          data\n        })\n      }\n    }\n    const block = this.getBlock(start.key)\n    let needRender = false\n    // is show format float box?\n    if (\n      start.key === end.key &&\n      start.offset !== end.offset &&\n      HAS_TEXT_BLOCK_REG.test(block.type) &&\n      block.functionType !== 'codeContent' &&\n      block.functionType !== 'languageInput'\n    ) {\n      const reference = this.getPositionReference()\n      const { formats } = this.selectionFormats()\n      eventCenter.dispatch('muya-format-picker', { reference, formats })\n    }\n\n    // update '```xxx' to code block when you click other place or use press arrow key.\n    if (block && start.key !== this.cursor.start.key) {\n      const oldBlock = this.getBlock(this.cursor.start.key)\n      if (oldBlock) {\n        needRender = needRender || this.codeBlockUpdate(oldBlock)\n      }\n    }\n\n    // change active status when paragraph changed\n    if (\n      start.key !== this.cursor.start.key ||\n      end.key !== this.cursor.end.key\n    ) {\n      needRender = true\n    }\n\n    const needMarkedUpdate = this.checkNeedRender(this.cursor) || this.checkNeedRender({ start, end })\n\n    if (needRender) {\n      this.cursor = { start, end }\n      return this.partialRender()\n    } else if (needMarkedUpdate) {\n      // Fix: whole select can not be canceled #613\n      requestAnimationFrame(() => {\n        const cursor = selection.getCursorRange()\n        if (!cursor.start || !cursor.end) {\n          return\n        }\n        this.cursor = cursor\n\n        return this.partialRender()\n      })\n    } else {\n      this.cursor = { start, end }\n    }\n  }\n\n  ContentState.prototype.setCheckBoxState = function (checkbox, checked) {\n    checkbox.checked = checked\n    const block = this.getBlock(checkbox.id)\n    block.checked = checked\n    checkbox.classList.toggle(CLASS_OR_ID.AG_CHECKBOX_CHECKED)\n  }\n\n  ContentState.prototype.updateParentsCheckBoxState = function (checkbox) {\n    let parent = getParentCheckBox(checkbox)\n    while (parent !== null) {\n      const checked = cumputeCheckboxStatus(parent)\n      if (parent.checked !== checked) {\n        this.setCheckBoxState(parent, checked)\n        parent = getParentCheckBox(parent)\n      } else {\n        break\n      }\n    }\n  }\n\n  ContentState.prototype.updateChildrenCheckBoxState = function (checkbox, checked) {\n    const checkboxes = checkbox.parentElement.querySelectorAll(`input ~ ul .${CLASS_OR_ID.AG_TASK_LIST_ITEM_CHECKBOX}`)\n    const len = checkboxes.length\n    for (let i = 0; i < len; i++) {\n      const checkbox = checkboxes[i]\n      if (checkbox.checked !== checked) {\n        this.setCheckBoxState(checkbox, checked)\n      }\n    }\n  }\n\n  // handle task list item checkbox click\n  ContentState.prototype.listItemCheckBoxClick = function (checkbox) {\n    const { checked } = checkbox\n    this.setCheckBoxState(checkbox, checked)\n\n    // A task checked, then related task should be update\n    const { autoCheck } = this.muya.options\n    if (autoCheck) {\n      this.updateChildrenCheckBoxState(checkbox, checked)\n      this.updateParentsCheckBoxState(checkbox)\n    }\n\n    const block = this.getBlock(checkbox.id)\n    const parentBlock = this.getParent(block)\n    const firstEditableBlock = this.firstInDescendant(parentBlock)\n    const { key } = firstEditableBlock\n    const offset = 0\n    this.cursor = { start: { key, offset }, end: { key, offset } }\n    return this.partialRender()\n  }\n}\n\nexport default clickCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\linkCtrl.js",["573"],"const linkCtrl = ContentState => {\n  /**\n   * Change a link into text.\n   */\n  ContentState.prototype.unlink = function (linkInfo) {\n    const { key, token } = linkInfo\n    const block = this.getBlock(key)\n    const { text } = block\n    let anchor\n    switch (token.type) {\n      case 'html_tag':\n        anchor = token.content\n        break\n      case 'link':\n        anchor = token.href\n        break\n      case 'text': {\n        const match = /^\\[(.+?)\\]/.exec(token.raw)\n        if (match && match[1]) {\n          anchor = match[1]\n        }\n        break\n      }\n    }\n    if (!anchor) {\n      console.error('Can not find anchor when unlink')\n      return\n    }\n    block.text = text.substring(0, token.range.start) + anchor + text.substring(token.range.end)\n    this.cursor = {\n      start: {\n        key,\n        offset: token.range.start\n      },\n      end: {\n        key,\n        offset: +token.range.start + anchor.length\n      }\n    }\n\n    this.singleRender(block)\n    return this.muya.dispatchChange()\n  }\n}\n\nexport default linkCtrl\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\selection\\cursor.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\footnoteCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\importMarkdown.js",["574","575"],"/**\n * translate markdown format to content state used by Mark Text\n * there is some difference when parse loose list item and tight lsit item.\n * Both of them add a p block in li block, use the CSS style to distinguish loose and tight.\n */\nimport StateRender from '../parser/render'\nimport { tokenizer } from '../parser'\nimport { getImageInfo } from '../utils'\nimport { Lexer } from '../parser/marked'\nimport ExportMarkdown from './exportMarkdown'\nimport TurndownService, { usePluginAddRules as _usePluginAddRules } from './turndownService'\nimport { loadLanguage } from '../prism/index'\n\n// To be disabled rules when parse markdown, Because content state don't need to parse inline rules\nimport { CURSOR_ANCHOR_DNA, CURSOR_FOCUS_DNA } from '../config'\n\n// Just because turndown change `\\n`(soft line break) to space, So we add `span.ag-soft-line-break` to workaround.\nconst turnSoftBreakToSpan = html => {\n  const parser = new DOMParser()\n  const doc = parser.parseFromString(\n    `<x-mt id=\"turn-root\">${html}</x-mt>`,\n    'text/html'\n  )\n  const root = doc.querySelector('#turn-root')\n  const travel = childNodes => {\n    for (const node of childNodes) {\n      if (node.nodeType === 3 && node.parentNode.tagName !== 'CODE') {\n        let startLen = 0\n        let endLen = 0\n        const text = node.nodeValue.replace(/^(\\n+)/, (_, p) => {\n          startLen = p.length\n          return ''\n        }).replace(/(\\n+)$/, (_, p) => {\n          endLen = p.length\n          return ''\n        })\n        if (/\\n/.test(text)) {\n          const tokens = text.split('\\n')\n          const params = []\n          let i = 0\n          const len = tokens.length\n          for (; i < len; i++) {\n            let text = tokens[i]\n            if (i === 0 && startLen !== 0) {\n              text = '\\n'.repeat(startLen) + text\n            } else if (i === len - 1 && endLen !== 0) {\n              text = text + '\\n'.repeat(endLen)\n            }\n            params.push(document.createTextNode(text))\n            if (i !== len - 1) {\n              const softBreak = document.createElement('span')\n              softBreak.classList.add('ag-soft-line-break')\n              params.push(softBreak)\n            }\n          }\n          node.replaceWith(...params)\n        }\n      } else if (node.nodeType === 1) {\n        travel(node.childNodes)\n      }\n    }\n  }\n  travel(root.childNodes)\n  return root.innerHTML.trim()\n}\n\nconst importRegister = ContentState => {\n  // turn markdown to blocks\n  ContentState.prototype.markdownToState = function (markdown) {\n    // mock a root block...\n    const rootState = {\n      key: null,\n      type: 'root',\n      text: '',\n      parent: null,\n      preSibling: null,\n      nextSibling: null,\n      children: []\n    }\n    const {\n      footnote,\n      isGitlabCompatibilityEnabled,\n      superSubScript,\n      trimUnnecessaryCodeBlockEmptyLines\n    } = this.muya.options\n\n    const tokens = new Lexer({\n      disableInline: true,\n      footnote,\n      isGitlabCompatibilityEnabled,\n      superSubScript\n    }).lex(markdown)\n\n    let token\n    let block\n    let value\n    const parentList = [rootState]\n    const languageLoaded = new Set()\n\n    while ((token = tokens.shift())) {\n      switch (token.type) {\n        case 'frontmatter': {\n          const { lang, style } = token\n          value = token.text\n            .replace(/^\\s+/, '')\n            .replace(/\\s$/, '')\n          block = this.createBlock('pre', {\n            functionType: token.type,\n            lang,\n            style\n          })\n\n          const codeBlock = this.createBlock('code', {\n            lang\n          })\n\n          const codeContent = this.createBlock('span', {\n            text: value,\n            lang,\n            functionType: 'codeContent'\n          })\n\n          this.appendChild(codeBlock, codeContent)\n          this.appendChild(block, codeBlock)\n          this.appendChild(parentList[0], block)\n          break\n        }\n\n        case 'hr': {\n          value = token.marker\n          block = this.createBlock('hr')\n          const thematicBreakContent = this.createBlock('span', {\n            text: value,\n            functionType: 'thematicBreakLine'\n          })\n          this.appendChild(block, thematicBreakContent)\n          this.appendChild(parentList[0], block)\n          break\n        }\n\n        case 'heading': {\n          const { headingStyle, depth, text, marker } = token\n          value = headingStyle === 'atx' ? '#'.repeat(+depth) + ` ${text}` : text\n          block = this.createBlock(`h${depth}`, {\n            headingStyle\n          })\n\n          const headingContent = this.createBlock('span', {\n            text: value,\n            functionType: headingStyle === 'atx' ? 'atxLine' : 'paragraphContent'\n          })\n\n          this.appendChild(block, headingContent)\n\n          if (marker) {\n            block.marker = marker\n          }\n\n          this.appendChild(parentList[0], block)\n          break\n        }\n\n        case 'multiplemath': {\n          value = token.text\n          block = this.createContainerBlock(token.type, value, token.mathStyle)\n          this.appendChild(parentList[0], block)\n          break\n        }\n\n        case 'code': {\n          const { codeBlockStyle, text, lang: infostring = '' } = token\n\n          // GH#697, markedjs#1387\n          const lang = (infostring || '').match(/\\S*/)[0]\n\n          value = text\n          // Fix: #1265.\n          if (trimUnnecessaryCodeBlockEmptyLines && (value.endsWith('\\n') || value.startsWith('\\n'))) {\n            value = value.replace(/\\n+$/, '')\n              .replace(/^\\n+/, '')\n          }\n          if (/mermaid|flowchart|vega-lite|sequence/.test(lang)) {\n            block = this.createContainerBlock(lang, value)\n            this.appendChild(parentList[0], block)\n          } else {\n            block = this.createBlock('pre', {\n              functionType: codeBlockStyle === 'fenced' ? 'fencecode' : 'indentcode',\n              lang\n            })\n            const codeBlock = this.createBlock('code', {\n              lang\n            })\n            const codeContent = this.createBlock('span', {\n              text: value,\n              lang,\n              functionType: 'codeContent'\n            })\n            const inputBlock = this.createBlock('span', {\n              text: lang,\n              functionType: 'languageInput'\n            })\n            if (lang && !languageLoaded.has(lang)) {\n              languageLoaded.add(lang)\n              loadLanguage(lang)\n                .then(infoList => {\n                  if (!Array.isArray(infoList)) return\n                  // There are three status `loaded`, `noexist` and `cached`.\n                  // if the status is `loaded`, indicated that it's a new loaded language\n                  const needRender = infoList.some(({ status }) => status === 'loaded')\n                  if (needRender) {\n                    this.render()\n                  }\n                })\n                .catch(err => {\n                  // if no parameter provided, will cause error.\n                  console.warn(err)\n                })\n            }\n\n            this.appendChild(codeBlock, codeContent)\n            this.appendChild(block, inputBlock)\n            this.appendChild(block, codeBlock)\n            this.appendChild(parentList[0], block)\n          }\n          break\n        }\n\n        case 'table': {\n          const { header, align, cells } = token\n          const table = this.createBlock('table')\n          const thead = this.createBlock('thead')\n          const tbody = this.createBlock('tbody')\n          const theadRow = this.createBlock('tr')\n          const restoreTableEscapeCharacters = text => {\n            // NOTE: markedjs replaces all escaped \"|\" (\"\\|\") characters inside a cell with \"|\".\n            //       We have to re-escape the chraracter to not break the table.\n            return text.replace(/\\|/g, '\\\\|')\n          }\n          let i\n          let j\n          const headerLen = header.length\n          for (i = 0; i < headerLen; i++) {\n            const headText = header[i]\n            const th = this.createBlock('th', {\n              align: align[i] || '',\n              column: i\n            })\n            const cellContent = this.createBlock('span', {\n              text: restoreTableEscapeCharacters(headText),\n              functionType: 'cellContent'\n            })\n            this.appendChild(th, cellContent)\n            this.appendChild(theadRow, th)\n          }\n          const rowLen = cells.length\n          for (i = 0; i < rowLen; i++) {\n            const rowBlock = this.createBlock('tr')\n            const rowContents = cells[i]\n            const colLen = rowContents.length\n            for (j = 0; j < colLen; j++) {\n              const cell = rowContents[j]\n              const td = this.createBlock('td', {\n                align: align[j] || '',\n                column: j\n              })\n              const cellContent = this.createBlock('span', {\n                text: restoreTableEscapeCharacters(cell),\n                functionType: 'cellContent'\n              })\n\n              this.appendChild(td, cellContent)\n              this.appendChild(rowBlock, td)\n            }\n            this.appendChild(tbody, rowBlock)\n          }\n\n          Object.assign(table, { row: cells.length, column: header.length - 1 }) // set row and column\n          block = this.createBlock('figure')\n          block.functionType = 'table'\n          this.appendChild(thead, theadRow)\n          this.appendChild(block, table)\n          this.appendChild(table, thead)\n          if (tbody.children.length) {\n            this.appendChild(table, tbody)\n          }\n          this.appendChild(parentList[0], block)\n          break\n        }\n\n        case 'html': {\n          const text = token.text.trim()\n          // TODO: Treat html block which only contains one img as paragraph, we maybe add image block in the future.\n          const isSingleImage = /^<img[^<>]+>$/.test(text)\n          if (isSingleImage) {\n            block = this.createBlock('p')\n            const contentBlock = this.createBlock('span', {\n              text\n            })\n            this.appendChild(block, contentBlock)\n            this.appendChild(parentList[0], block)\n          } else {\n            block = this.createHtmlBlock(text)\n            this.appendChild(parentList[0], block)\n          }\n          break\n        }\n\n        case 'text': {\n          value = token.text\n          while (tokens[0].type === 'text') {\n            token = tokens.shift()\n            value += `\\n${token.text}`\n          }\n          block = this.createBlock('p')\n          const contentBlock = this.createBlock('span', {\n            text: value\n          })\n          this.appendChild(block, contentBlock)\n          this.appendChild(parentList[0], block)\n          break\n        }\n\n        case 'toc':\n        case 'paragraph': {\n          value = token.text\n          block = this.createBlock('p')\n          const contentBlock = this.createBlock('span', {\n            text: value\n          })\n          this.appendChild(block, contentBlock)\n          this.appendChild(parentList[0], block)\n          break\n        }\n\n        case 'blockquote_start': {\n          block = this.createBlock('blockquote')\n          this.appendChild(parentList[0], block)\n          parentList.unshift(block)\n          break\n        }\n\n        case 'blockquote_end': {\n          // Fix #1735 the blockquote maybe empty.\n          if (parentList[0].children.length === 0) {\n            const paragraphBlock = this.createBlockP()\n            this.appendChild(parentList[0], paragraphBlock)\n          }\n          parentList.shift()\n          break\n        }\n\n        case 'footnote_start': {\n          block = this.createBlock('figure', {\n            functionType: 'footnote'\n          })\n          const identifierInput = this.createBlock('span', {\n            text: token.identifier,\n            functionType: 'footnoteInput'\n          })\n          this.appendChild(block, identifierInput)\n          this.appendChild(parentList[0], block)\n          parentList.unshift(block)\n          break\n        }\n\n        case 'footnote_end': {\n          parentList.shift()\n          break\n        }\n\n        case 'list_start': {\n          const { ordered, listType, start } = token\n          block = this.createBlock(ordered === true ? 'ol' : 'ul')\n          block.listType = listType\n          if (listType === 'order') {\n            block.start = /^\\d+$/.test(start) ? start : 1\n          }\n          this.appendChild(parentList[0], block)\n          parentList.unshift(block)\n          break\n        }\n\n        case 'list_end': {\n          parentList.shift()\n          break\n        }\n\n        case 'loose_item_start':\n        case 'list_item_start': {\n          const { listItemType, bulletMarkerOrDelimiter, checked, type } = token\n          block = this.createBlock('li', {\n            listItemType: checked !== undefined ? 'task' : listItemType,\n            bulletMarkerOrDelimiter,\n            isLooseListItem: type === 'loose_item_start'\n          })\n\n          if (checked !== undefined) {\n            const input = this.createBlock('input', {\n              checked\n            })\n\n            this.appendChild(block, input)\n          }\n          this.appendChild(parentList[0], block)\n          parentList.unshift(block)\n          break\n        }\n\n        case 'list_item_end': {\n          parentList.shift()\n          break\n        }\n\n        case 'space': {\n          break\n        }\n\n        default:\n          console.warn(`Unknown type ${token.type}`)\n          break\n      }\n    }\n    languageLoaded.clear()\n    return rootState.children.length ? rootState.children : [this.createBlockP()]\n  }\n\n  ContentState.prototype.htmlToMarkdown = function (html, keeps = []) {\n    // turn html to markdown\n    const { turndownConfig } = this\n    const turndownService = new TurndownService(turndownConfig)\n    _usePluginAddRules(turndownService, keeps)\n\n    // fix #752, but I don't know why the &nbsp; vanlished.\n    html = html.replace(/<span>&nbsp;<\\/span>/g, String.fromCharCode(160))\n\n    html = turnSoftBreakToSpan(html)\n    const markdown = turndownService.turndown(html)\n\n    return markdown\n  }\n\n  // turn html to blocks\n  ContentState.prototype.html2State = function (html) {\n    const markdown = this.htmlToMarkdown(html, ['ruby', 'rt', 'u', 'br'])\n    return this.markdownToState(markdown)\n  }\n\n  ContentState.prototype.getCodeMirrorCursor = function () {\n    const blocks = this.getBlocks()\n    const { anchor, focus } = this.cursor\n    const anchorBlock = this.getBlock(anchor.key)\n    const focusBlock = this.getBlock(focus.key)\n    const { text: anchorText } = anchorBlock\n    const { text: focusText } = focusBlock\n    if (anchor.key === focus.key) {\n      const minOffset = Math.min(anchor.offset, focus.offset)\n      const maxOffset = Math.max(anchor.offset, focus.offset)\n      const firstTextPart = anchorText.substring(0, minOffset)\n      const secondTextPart = anchorText.substring(minOffset, maxOffset)\n      const thirdTextPart = anchorText.substring(maxOffset)\n      anchorBlock.text = firstTextPart +\n        (anchor.offset <= focus.offset ? CURSOR_ANCHOR_DNA : CURSOR_FOCUS_DNA) +\n        secondTextPart +\n        (anchor.offset <= focus.offset ? CURSOR_FOCUS_DNA : CURSOR_ANCHOR_DNA) +\n        thirdTextPart\n    } else {\n      anchorBlock.text = anchorText.substring(0, anchor.offset) + CURSOR_ANCHOR_DNA + anchorText.substring(anchor.offset)\n      focusBlock.text = focusText.substring(0, focus.offset) + CURSOR_FOCUS_DNA + focusText.substring(focus.offset)\n    }\n\n    const { isGitlabCompatibilityEnabled, listIndentation } = this\n    const markdown = new ExportMarkdown(blocks, listIndentation, isGitlabCompatibilityEnabled).generate()\n    const cursor = markdown.split('\\n').reduce((acc, line, index) => {\n      const ach = line.indexOf(CURSOR_ANCHOR_DNA)\n      const fch = line.indexOf(CURSOR_FOCUS_DNA)\n      if (ach > -1 && fch > -1) {\n        if (ach <= fch) {\n          Object.assign(acc.anchor, { line: index, ch: ach })\n          Object.assign(acc.focus, { line: index, ch: fch - CURSOR_ANCHOR_DNA.length })\n        } else {\n          Object.assign(acc.focus, { line: index, ch: fch })\n          Object.assign(acc.anchor, { line: index, ch: ach - CURSOR_FOCUS_DNA.length })\n        }\n      } else if (ach > -1) {\n        Object.assign(acc.anchor, { line: index, ch: ach })\n      } else if (fch > -1) {\n        Object.assign(acc.focus, { line: index, ch: fch })\n      }\n      return acc\n    }, {\n      anchor: {\n        line: 0,\n        ch: 0\n      },\n      focus: {\n        line: 0,\n        ch: 0\n      }\n    })\n    // remove CURSOR_FOCUS_DNA and CURSOR_ANCHOR_DNA\n    anchorBlock.text = anchorText\n    focusBlock.text = focusText\n    return cursor\n  }\n\n  ContentState.prototype.addCursorToMarkdown = function (markdown, cursor) {\n    const { anchor, focus } = cursor\n    if (!anchor || !focus) {\n      return\n    }\n    const lines = markdown.split('\\n')\n    const anchorText = lines[anchor.line]\n    const focusText = lines[focus.line]\n    if (!anchorText || !focusText) {\n      return {\n        markdown: lines.join('\\n'),\n        isValid: false\n      }\n    }\n    if (anchor.line === focus.line) {\n      const minOffset = Math.min(anchor.ch, focus.ch)\n      const maxOffset = Math.max(anchor.ch, focus.ch)\n      const firstTextPart = anchorText.substring(0, minOffset)\n      const secondTextPart = anchorText.substring(minOffset, maxOffset)\n      const thirdTextPart = anchorText.substring(maxOffset)\n      lines[anchor.line] = firstTextPart +\n        (anchor.ch <= focus.ch ? CURSOR_ANCHOR_DNA : CURSOR_FOCUS_DNA) +\n        secondTextPart +\n        (anchor.ch <= focus.ch ? CURSOR_FOCUS_DNA : CURSOR_ANCHOR_DNA) +\n        thirdTextPart\n    } else {\n      lines[anchor.line] = anchorText.substring(0, anchor.ch) + CURSOR_ANCHOR_DNA + anchorText.substring(anchor.ch)\n      lines[focus.line] = focusText.substring(0, focus.ch) + CURSOR_FOCUS_DNA + focusText.substring(focus.ch)\n    }\n\n    return {\n      markdown: lines.join('\\n'),\n      isValid: true\n    }\n  }\n\n  ContentState.prototype.importCursor = function (hasCursor) {\n    // set cursor\n    const cursor = {\n      anchor: null,\n      focus: null\n    }\n\n    let count = 0\n\n    const travel = blocks => {\n      for (const block of blocks) {\n        let { key, text, children, editable } = block\n        if (text) {\n          const offset = text.indexOf(CURSOR_ANCHOR_DNA)\n          if (offset > -1) {\n            block.text = text.substring(0, offset) + text.substring(offset + CURSOR_ANCHOR_DNA.length)\n            text = block.text\n            count++\n            if (editable) {\n              cursor.anchor = { key, offset }\n            }\n          }\n          const focusOffset = text.indexOf(CURSOR_FOCUS_DNA)\n          if (focusOffset > -1) {\n            block.text = text.substring(0, focusOffset) + text.substring(focusOffset + CURSOR_FOCUS_DNA.length)\n            count++\n            if (editable) {\n              cursor.focus = { key, offset: focusOffset }\n            }\n          }\n          if (count === 2) {\n            break\n          }\n        } else if (children.length) {\n          travel(children)\n        }\n      }\n    }\n    if (hasCursor) {\n      travel(this.blocks)\n    } else {\n      const lastBlock = this.getLastBlock()\n      const key = lastBlock.key\n      const offset = lastBlock.text.length\n      cursor.anchor = { key, offset }\n      cursor.focus = { key, offset }\n    }\n    if (cursor.anchor && cursor.focus) {\n      this.cursor = cursor\n    }\n  }\n\n  ContentState.prototype.importMarkdown = function (markdown) {\n    this.blocks = this.markdownToState(markdown)\n  }\n\n  ContentState.prototype.extractImages = function (markdown) {\n    const results = new Set()\n    const blocks = this.markdownToState(markdown)\n    const render = new StateRender(this.muya)\n    render.collectLabels(blocks)\n\n    const travelToken = token => {\n      const { type, attrs, children, tag, label, backlash } = token\n      if (/reference_image|image/.test(type) || type === 'html_tag' && tag === 'img') {\n        if ((type === 'image' || type === 'html_tag') && attrs.src) {\n          results.add(attrs.src)\n        } else {\n          const rawSrc = label + backlash.second\n          if (render.labels.has((rawSrc).toLowerCase())) {\n            const { href } = render.labels.get(rawSrc.toLowerCase())\n            const { src } = getImageInfo(href)\n            if (src) {\n              results.add(src)\n            }\n          }\n        }\n      } else if (children && children.length) {\n        for (const child of children) {\n          travelToken(child)\n        }\n      }\n    }\n\n    const travel = block => {\n      const { text, children, type, functionType } = block\n      if (children.length) {\n        for (const b of children) {\n          travel(b)\n        }\n      } else if (text && type === 'span' && /paragraphContent|atxLine|cellContent/.test(functionType)) {\n        const tokens = tokenizer(text, [], false, render.labels)\n        for (const token of tokens) {\n          travelToken(token)\n        }\n      }\n    }\n\n    for (const block of blocks) {\n      travel(block)\n    }\n\n    return Array.from(results)\n  }\n}\n\nexport default importRegister\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\contentState\\dragDropCtrl.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\selection\\index.js",["576","577","578"],"/**\n * This file is copy from [medium-editor](https://github.com/yabwe/medium-editor)\n * and customize for specialized use.\n */\nimport Cursor from './cursor'\nimport { CLASS_OR_ID } from '../config'\nimport {\n  isBlockContainer,\n  traverseUp,\n  getFirstSelectableLeafNode,\n  getClosestBlockContainer,\n  getCursorPositionWithinMarkedText,\n  findNearestParagraph,\n  getTextContent,\n  getOffsetOfParagraph\n} from './dom'\n\nconst filterOnlyParentElements = node => {\n  return isBlockContainer(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n}\n\nclass Selection {\n  constructor (doc) {\n    this.doc = doc // document\n  }\n\n  findMatchingSelectionParent (testElementFunction, contentWindow) {\n    const selection = contentWindow.getSelection()\n    let range\n    let current\n\n    if (selection.rangeCount === 0) {\n      return false\n    }\n\n    range = selection.getRangeAt(0)\n    current = range.commonAncestorContainer\n\n    return traverseUp(current, testElementFunction)\n  }\n\n  // https://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html\n  // Tim Down\n  //\n  // {object} selectionState - the selection to import\n  // {DOMElement} root - the root element the selection is being restored inside of\n  // {boolean} [favorLaterSelectionAnchor] - defaults to false. If true, import the cursor immediately\n  //      subsequent to an anchor tag if it would otherwise be placed right at the trailing edge inside the\n  //      anchor. This cursor positioning, even though visually equivalent to the user, can affect behavior\n  //      in MS IE.\n  importSelection (selectionState, root, favorLaterSelectionAnchor) {\n    if (!selectionState || !root) {\n      throw new Error('your must provide a [selectionState] and a [root] element')\n    }\n\n    let range = this.doc.createRange()\n    range.setStart(root, 0)\n    range.collapse(true)\n\n    let node = root\n    const nodeStack = []\n    let charIndex = 0\n    let foundStart = false\n    let foundEnd = false\n    let trailingImageCount = 0\n    let stop = false\n    let nextCharIndex\n    let allowRangeToStartAtEndOfNode = false\n    let lastTextNode = null\n\n    // When importing selection, the start of the selection may lie at the end of an element\n    // or at the beginning of an element.  Since visually there is no difference between these 2\n    // we will try to move the selection to the beginning of an element since this is generally\n    // what users will expect and it's a more predictable behavior.\n    //\n    // However, there are some specific cases when we don't want to do this:\n    //  1) We're attempting to move the cursor outside of the end of an anchor [favorLaterSelectionAnchor = true]\n    //  2) The selection starts with an image, which is special since an image doesn't have any 'content'\n    //     as far as selection and ranges are concerned\n    //  3) The selection starts after a specified number of empty block elements (selectionState.emptyBlocksIndex)\n    //\n    // For these cases, we want the selection to start at a very specific location, so we should NOT\n    // automatically move the cursor to the beginning of the first actual chunk of text\n    if (favorLaterSelectionAnchor || selectionState.startsWithImage || typeof selectionState.emptyBlocksIndex !== 'undefined') {\n      allowRangeToStartAtEndOfNode = true\n    }\n\n    while (!stop && node) {\n      // Only iterate over elements and text nodes\n      if (node.nodeType > 3) {\n        node = nodeStack.pop()\n        continue\n      }\n\n      // If we hit a text node, we need to add the amount of characters to the overall count\n      if (node.nodeType === 3 && !foundEnd) {\n        nextCharIndex = charIndex + node.length\n        // Check if we're at or beyond the start of the selection we're importing\n        if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {\n          // NOTE: We only want to allow a selection to start at the END of an element if\n          //  allowRangeToStartAtEndOfNode is true\n          if (allowRangeToStartAtEndOfNode || selectionState.start < nextCharIndex) {\n            range.setStart(node, selectionState.start - charIndex)\n            foundStart = true\n          } else {\n            // We're at the end of a text node where the selection could start but we shouldn't\n            // make the selection start here because allowRangeToStartAtEndOfNode is false.\n            // However, we should keep a reference to this node in case there aren't any more\n            // text nodes after this, so that we have somewhere to import the selection to\n            lastTextNode = node\n          }\n        }\n        // We've found the start of the selection, check if we're at or beyond the end of the selection we're importing\n        if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {\n          if (!selectionState.trailingImageCount) {\n            range.setEnd(node, selectionState.end - charIndex)\n            stop = true\n          } else {\n            foundEnd = true\n          }\n        }\n        charIndex = nextCharIndex\n      } else {\n        if (selectionState.trailingImageCount && foundEnd) {\n          if (node.nodeName.toLowerCase() === 'img') {\n            trailingImageCount++\n          }\n          if (trailingImageCount === selectionState.trailingImageCount) {\n            // Find which index the image is in its parent's children\n            let endIndex = 0\n            while (node.parentNode.childNodes[endIndex] !== node) {\n              endIndex++\n            }\n            range.setEnd(node.parentNode, endIndex + 1)\n            stop = true\n          }\n        }\n\n        if (!stop && node.nodeType === 1) {\n          // this is an element\n          // add all its children to the stack\n          let i = node.childNodes.length - 1\n          while (i >= 0) {\n            nodeStack.push(node.childNodes[i])\n            i -= 1\n          }\n        }\n      }\n\n      if (!stop) {\n        node = nodeStack.pop()\n      }\n    }\n\n    // If we've gone through the entire text but didn't find the beginning of a text node\n    // to make the selection start at, we should fall back to starting the selection\n    // at the END of the last text node we found\n    if (!foundStart && lastTextNode) {\n      range.setStart(lastTextNode, lastTextNode.length)\n      range.setEnd(lastTextNode, lastTextNode.length)\n    }\n\n    if (typeof selectionState.emptyBlocksIndex !== 'undefined') {\n      range = this.importSelectionMoveCursorPastBlocks(root, selectionState.emptyBlocksIndex, range)\n    }\n\n    // If the selection is right at the ending edge of a link, put it outside the anchor tag instead of inside.\n    if (favorLaterSelectionAnchor) {\n      range = this.importSelectionMoveCursorPastAnchor(selectionState, range)\n    }\n\n    this.selectRange(range)\n  }\n\n  // Utility method called from importSelection only\n  importSelectionMoveCursorPastAnchor (selectionState, range) {\n    const nodeInsideAnchorTagFunction = function (node) {\n      return node.nodeName.toLowerCase() === 'a'\n    }\n    if (selectionState.start === selectionState.end &&\n      range.startContainer.nodeType === 3 &&\n      range.startOffset === range.startContainer.nodeValue.length &&\n      traverseUp(range.startContainer, nodeInsideAnchorTagFunction)) {\n      let prevNode = range.startContainer\n      let currentNode = range.startContainer.parentNode\n      while (currentNode !== null && currentNode.nodeName.toLowerCase() !== 'a') {\n        if (currentNode.childNodes[currentNode.childNodes.length - 1] !== prevNode) {\n          currentNode = null\n        } else {\n          prevNode = currentNode\n          currentNode = currentNode.parentNode\n        }\n      }\n      if (currentNode !== null && currentNode.nodeName.toLowerCase() === 'a') {\n        let currentNodeIndex = null\n        for (let i = 0; currentNodeIndex === null && i < currentNode.parentNode.childNodes.length; i++) {\n          if (currentNode.parentNode.childNodes[i] === currentNode) {\n            currentNodeIndex = i\n          }\n        }\n        range.setStart(currentNode.parentNode, currentNodeIndex + 1)\n        range.collapse(true)\n      }\n    }\n    return range\n  }\n\n  // Uses the emptyBlocksIndex calculated by getIndexRelativeToAdjacentEmptyBlocks\n  // to move the cursor back to the start of the correct paragraph\n  importSelectionMoveCursorPastBlocks (root, index = 1, range) {\n    const treeWalker = this.doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false)\n    const startContainer = range.startContainer\n    let startBlock\n    let targetNode\n    let currIndex = 0\n    // If index is 0, we still want to move to the next block\n\n    // Chrome counts newlines and spaces that separate block elements as actual elements.\n    // If the selection is inside one of these text nodes, and it has a previous sibling\n    // which is a block element, we want the treewalker to start at the previous sibling\n    // and NOT at the parent of the textnode\n    if (startContainer.nodeType === 3 && isBlockContainer(startContainer.previousSibling)) {\n      startBlock = startContainer.previousSibling\n    } else {\n      startBlock = getClosestBlockContainer(startContainer)\n    }\n\n    // Skip over empty blocks until we hit the block we want the selection to be in\n    while (treeWalker.nextNode()) {\n      if (!targetNode) {\n        // Loop through all blocks until we hit the starting block element\n        if (startBlock === treeWalker.currentNode) {\n          targetNode = treeWalker.currentNode\n        }\n      } else {\n        targetNode = treeWalker.currentNode\n        currIndex++\n        // We hit the target index, bail\n        if (currIndex === index) {\n          break\n        }\n        // If we find a non-empty block, ignore the emptyBlocksIndex and just put selection here\n        if (targetNode.textContent.length > 0) {\n          break\n        }\n      }\n    }\n\n    if (!targetNode) {\n      targetNode = startBlock\n    }\n\n    // We're selecting a high-level block node, so make sure the cursor gets moved into the deepest\n    // element at the beginning of the block\n    range.setStart(getFirstSelectableLeafNode(targetNode), 0)\n\n    return range\n  }\n\n  // https://stackoverflow.com/questions/4176923/html-of-selected-text\n  // by Tim Down\n  getSelectionHtml () {\n    const sel = this.doc.getSelection()\n    let i\n    let html = ''\n    let len\n    let container\n    if (sel.rangeCount) {\n      container = this.doc.createElement('div')\n      for (i = 0, len = sel.rangeCount; i < len; i += 1) {\n        container.appendChild(sel.getRangeAt(i).cloneContents())\n      }\n      html = container.innerHTML\n    }\n    return html\n  }\n\n  chopHtmlByCursor (root) {\n    const { left } = this.getCaretOffsets(root)\n    const markedText = root.textContent\n    const { type, info } = getCursorPositionWithinMarkedText(markedText, left)\n    const pre = markedText.slice(0, left)\n    const post = markedText.slice(left)\n    switch (type) {\n      case 'OUT':\n        return {\n          pre,\n          post\n        }\n      case 'IN':\n        return {\n          pre: `${pre}${info}`,\n          post: `${info}${post}`\n        }\n      case 'LEFT':\n        return {\n          pre: markedText.slice(0, left - info),\n          post: markedText.slice(left - info)\n        }\n      case 'RIGHT':\n        return {\n          pre: markedText.slice(0, left + info),\n          post: markedText.slice(left + info)\n        }\n    }\n  }\n\n  /**\n   *  Find the caret position within an element irrespective of any inline tags it may contain.\n   *\n   *  @param {DOMElement} An element containing the cursor to find offsets relative to.\n   *  @param {Range} A Range representing cursor position. Will window.getSelection if none is passed.\n   *  @return {Object} 'left' and 'right' attributes contain offsets from beginning and end of Element\n   */\n  getCaretOffsets (element, range) {\n    let preCaretRange\n    let postCaretRange\n\n    if (!range) {\n      range = window.getSelection().getRangeAt(0)\n    }\n\n    preCaretRange = range.cloneRange()\n    postCaretRange = range.cloneRange()\n\n    preCaretRange.selectNodeContents(element)\n    preCaretRange.setEnd(range.endContainer, range.endOffset)\n\n    postCaretRange.selectNodeContents(element)\n    postCaretRange.setStart(range.endContainer, range.endOffset)\n\n    return {\n      left: preCaretRange.toString().length,\n      right: postCaretRange.toString().length\n    }\n  }\n\n  selectNode (node) {\n    const range = this.doc.createRange()\n    range.selectNodeContents(node)\n    this.selectRange(range)\n  }\n\n  select (startNode, startOffset, endNode, endOffset) {\n    const range = this.doc.createRange()\n    range.setStart(startNode, startOffset)\n    if (endNode) {\n      range.setEnd(endNode, endOffset)\n    } else {\n      range.collapse(true)\n    }\n    this.selectRange(range)\n    return range\n  }\n\n  setFocus (focusNode, focusOffset) {\n    const selection = this.doc.getSelection()\n    selection.extend(focusNode, focusOffset)\n  }\n\n  /**\n   *  Clear the current highlighted selection and set the caret to the start or the end of that prior selection, defaults to end.\n   *\n   *  @param {boolean} moveCursorToStart  A boolean representing whether or not to set the caret to the beginning of the prior selection.\n   */\n  clearSelection (moveCursorToStart) {\n    const { rangeCount } = this.doc.getSelection()\n    if (!rangeCount) return\n    if (moveCursorToStart) {\n      this.doc.getSelection().collapseToStart()\n    } else {\n      this.doc.getSelection().collapseToEnd()\n    }\n  }\n\n  /**\n   * Move cursor to the given node with the given offset.\n   *\n   * @param  {DomElement}  node    Element where to jump\n   * @param  {integer}     offset  Where in the element should we jump, 0 by default\n   */\n  moveCursor (node, offset) {\n    this.select(node, offset)\n  }\n\n  getSelectionRange () {\n    const selection = this.doc.getSelection()\n    if (selection.rangeCount === 0) {\n      return null\n    }\n    return selection.getRangeAt(0)\n  }\n\n  selectRange (range) {\n    const selection = this.doc.getSelection()\n\n    selection.removeAllRanges()\n    selection.addRange(range)\n  }\n\n  // https://stackoverflow.com/questions/1197401/\n  // how-can-i-get-the-element-the-caret-is-in-with-javascript-when-using-contenteditable\n  // by You\n  getSelectionStart () {\n    const node = this.doc.getSelection().anchorNode\n    const startNode = (node && node.nodeType === 3 ? node.parentNode : node)\n\n    return startNode\n  }\n\n  setCursorRange (cursorRange) {\n    const { anchor, focus } = cursorRange\n    const anchorParagraph = document.querySelector(`#${anchor.key}`)\n    const focusParagraph = document.querySelector(`#${focus.key}`)\n    const getNodeAndOffset = (node, offset) => {\n      if (node.nodeType === 3) {\n        return {\n          node,\n          offset\n        }\n      }\n\n      const childNodes = node.childNodes\n      const len = childNodes.length\n      let i\n      let count = 0\n      for (i = 0; i < len; i++) {\n        const child = childNodes[i]\n        const textContent = getTextContent(child, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER])\n        const textLength = textContent.length\n        if (child.classList && child.classList.contains(CLASS_OR_ID.AG_FRONT_ICON)) {\n          continue\n        }\n\n        // Fix #1460 - put the cursor at the next text node or element if it can be put at the last of /^\\n$/ or the next text node/element.\n        if (/^\\n$/.test(textContent) && i !== len - 1 ? count + textLength > offset : count + textLength >= offset) {\n          if (\n            child.classList && child.classList.contains('ag-inline-image')\n          ) {\n            const imageContainer = child.querySelector('.ag-image-container')\n            const hasImg = imageContainer.querySelector('img')\n\n            if (!hasImg) {\n              return {\n                node: child,\n                offset: 0\n              }\n            }\n            if (count + textLength === offset) {\n              if (child.nextElementSibling) {\n                return {\n                  node: child.nextElementSibling,\n                  offset: 0\n                }\n              } else {\n                return {\n                  node: imageContainer,\n                  offset: 1\n                }\n              }\n            } else if (count === offset && count === 0) {\n              return {\n                node: imageContainer,\n                offset: 0\n              }\n            } else {\n              return {\n                node: child,\n                offset: 0\n              }\n            }\n          } else {\n            return getNodeAndOffset(child, offset - count)\n          }\n        } else {\n          count += textLength\n        }\n      }\n      return { node, offset }\n    }\n\n    let { node: anchorNode, offset: anchorOffset } = getNodeAndOffset(anchorParagraph, anchor.offset)\n    let { node: focusNode, offset: focusOffset } = getNodeAndOffset(focusParagraph, focus.offset)\n\n    if (anchorNode.nodeType === 3 || anchorNode.nodeType === 1 && !anchorNode.classList.contains('ag-image-container')) {\n      anchorOffset = Math.min(anchorOffset, anchorNode.textContent.length)\n      focusOffset = Math.min(focusOffset, focusNode.textContent.length)\n    }\n\n    // First set the anchor node and anchor offset, make it collapsed\n    this.select(anchorNode, anchorOffset)\n    // Secondly, set the focus node and focus offset.\n    this.setFocus(focusNode, focusOffset)\n  }\n\n  isValidCursorNode (node) {\n    if (!node) return false\n    if (node.nodeType === 3) {\n      node = node.parentNode\n    }\n\n    return node.closest('span.ag-paragraph')\n  }\n\n  getCursorRange () {\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = this.doc.getSelection()\n    const isAnchorValid = this.isValidCursorNode(anchorNode)\n    const isFocusValid = this.isValidCursorNode(focusNode)\n    let needFix = false\n    if (!isAnchorValid && isFocusValid) {\n      needFix = true\n      anchorNode = focusNode\n      anchorOffset = focusOffset\n    } else if (isAnchorValid && !isFocusValid) {\n      needFix = true\n      focusNode = anchorNode\n      focusOffset = anchorOffset\n    } else if (!isAnchorValid && !isFocusValid) {\n      const editor = document.querySelector('#ag-editor-id').parentNode\n      editor.blur()\n\n      return new Cursor({\n        start: null,\n        end: null,\n        anchor: null,\n        focus: null\n      })\n    }\n\n    // fix bug click empty line, the cursor will jump to the end of pre line.\n    if (\n      anchorNode === focusNode &&\n      anchorOffset === focusOffset &&\n      anchorNode.textContent === '\\n' &&\n      focusOffset === 0\n    ) {\n      focusOffset = anchorOffset = 1\n    }\n\n    const anchorParagraph = findNearestParagraph(anchorNode)\n    const focusParagraph = findNearestParagraph(focusNode)\n\n    let aOffset = getOffsetOfParagraph(anchorNode, anchorParagraph) + anchorOffset\n    let fOffset = getOffsetOfParagraph(focusNode, focusParagraph) + focusOffset\n\n    // fix input after image.\n    if (\n      anchorNode === focusNode &&\n      anchorOffset === focusOffset &&\n      anchorNode.parentNode.classList.contains('ag-image-container') &&\n      anchorNode.previousElementSibling &&\n      anchorNode.previousElementSibling.nodeName === 'IMG'\n    ) {\n      const imageWrapper = anchorNode.parentNode.parentNode\n      const preElement = imageWrapper.previousElementSibling\n      aOffset = 0\n      if (preElement) {\n        aOffset += getOffsetOfParagraph(preElement, anchorParagraph)\n        aOffset += getTextContent(preElement, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER]).length\n      }\n      aOffset += getTextContent(imageWrapper, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER]).length\n      fOffset = aOffset\n    }\n\n    if (\n      anchorNode === focusNode &&\n      anchorNode.nodeType === 1 &&\n      anchorNode.classList.contains('ag-image-container')\n    ) {\n      const imageWrapper = anchorNode.parentNode\n      const preElement = imageWrapper.previousElementSibling\n      aOffset = 0\n      if (preElement) {\n        aOffset += getOffsetOfParagraph(preElement, anchorParagraph)\n        aOffset += getTextContent(preElement, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER]).length\n      }\n      if (anchorOffset === 1) {\n        aOffset += getTextContent(imageWrapper, [CLASS_OR_ID.AG_MATH_RENDER, CLASS_OR_ID.AG_RUBY_RENDER]).length\n      }\n      fOffset = aOffset\n    }\n\n    const anchor = { key: anchorParagraph.id, offset: aOffset }\n\n    const focus = { key: focusParagraph.id, offset: fOffset }\n    const result = new Cursor({ anchor, focus })\n\n    if (needFix) {\n      this.setCursorRange(result)\n    }\n\n    return result\n  }\n\n  // topOffset is the line counts above cursor, and bottomOffset is line counts bellow cursor.\n  getCursorYOffset (paragraph) {\n    const { y } = this.getCursorCoords()\n    const { height, top } = paragraph.getBoundingClientRect()\n    const lineHeight = parseFloat(getComputedStyle(paragraph).lineHeight)\n    const topOffset = Math.round((y - top) / lineHeight)\n    const bottomOffset = Math.round((top + height - lineHeight - y) / lineHeight)\n\n    return {\n      topOffset,\n      bottomOffset\n    }\n  }\n\n  getCursorCoords () {\n    const sel = this.doc.getSelection()\n    let range\n    let x = 0\n    let y = 0\n    let width = 0\n\n    if (sel.rangeCount) {\n      range = sel.getRangeAt(0).cloneRange()\n      if (range.getClientRects) {\n        // range.collapse(true)\n        let rects = range.getClientRects()\n        if (rects.length === 0 && range.startContainer && (range.startContainer.nodeType === Node.ELEMENT_NODE || range.startContainer.nodeType === Node.TEXT_NODE)) {\n          rects = range.startContainer.parentElement.getClientRects()\n          // prevent tiny vibrations\n          if (rects.length) {\n            const rect = rects[0]\n            rect.y = rect.y + 1\n          }\n        }\n        if (rects.length) {\n          const { left, top, x: rectX, y: rectY, width: rWidth } = rects[0]\n          x = rectX || left\n          y = rectY || top\n          width = rWidth\n        }\n      }\n    }\n\n    return { x, y, width }\n  }\n\n  getSelectionEnd () {\n    const node = this.doc.getSelection().focusNode\n    const endNode = (node && node.nodeType === 3 ? node.parentNode : node)\n\n    return endNode\n  }\n}\n\nexport default new Selection(document)\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\renderers\\index.js",["579"],"const rendererCache = new Map()\n/**\n *\n * @param {string} name the renderer name: katex, sequence, flowchart, mermaid, vega-lite\n */\nconst loadRenderer = async (name) => {\n  if (!rendererCache.has(name)) {\n    let m\n    switch (name) {\n      case 'sequence':\n        // m = await import('../parser/render/sequence')\n        // rendererCache.set(name, m.default)\n        break\n      case 'flowchart':\n        // m = await import('flowchart.js')\n        // rendererCache.set(name, m.default)\n        break\n      case 'mermaid':\n        // m = await import('mermaid/dist/mermaid.core')\n        // rendererCache.set(name, m.default)\n        break\n      case 'vega-lite':\n        // m = await import('vega-embed')\n        // rendererCache.set(name, m.default)\n        break\n      default:\n        throw new Error(`Unknown diagram name ${name}`)\n    }\n  }\n\n  return rendererCache.get(name)\n}\n\nexport default loadRenderer\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\emojis\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\escapeCharacter.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\getParentCheckBox.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\rules.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\cumputeCheckBoxStatus.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\utils\\turndownService.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\sequence.js",[],["580","581"],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\renderer.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\parser.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\options.js",["582"],"export default {\n  baseUrl: null,\n  breaks: false,\n  gfm: true,\n  headerIds: true,\n  headerPrefix: '',\n  highlight: null,\n  mathRenderer: null,\n  emojiRenderer: null,\n  tocRenderer: null,\n  langPrefix: 'language-',\n  mangle: true,\n  pedantic: false,\n  renderer: null, // new Renderer(),\n  silent: false,\n  smartLists: false,\n  smartypants: false,\n  xhtml: false,\n  disableInline: false,\n\n  // NOTE: sanitize and sanitizer are deprecated since version 0.7.0, should not be used and will be removed in the future.\n  sanitize: false,\n  sanitizer: null,\n\n  // Markdown extensions:\n  // TODO: We set whether to support `emoji`, `math`, `frontMatter` default value to `true`\n  // After we add user setting, we maybe set math and frontMatter default value to false.\n  // User need to enable them in the user setting.\n  emoji: true,\n  math: true,\n  frontMatter: true,\n  superSubScript: false,\n  footnote: false,\n  isGitlabCompatibilityEnabled: false,\n\n  isHtmlEnabled: true\n}\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\lexer.js",["583"],"import { normal, gfm, pedantic } from './blockRules'\nimport options from './options'\nimport { splitCells, rtrim, getUniqueId } from './utils'\n\n/**\n * Block Lexer\n */\n\nfunction Lexer (opts) {\n  this.tokens = []\n  this.tokens.links = Object.create(null)\n  this.tokens.footnotes = Object.create(null)\n  this.footnoteOrder = 0\n  this.options = Object.assign({}, options, opts)\n  this.rules = normal\n\n  if (this.options.pedantic) {\n    this.rules = pedantic\n  } else if (this.options.gfm) {\n    this.rules = gfm\n  }\n}\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function (src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n  this.checkFrontmatter = true\n  this.footnoteOrder = 0\n  this.token(src, true)\n\n  // Move footnote token to the end of tokens.\n  const { tokens } = this\n  const hasNoFootnoteTokens = []\n  const footnoteTokens = []\n  let isInFootnote = false\n  for (const token of tokens) {\n    const { type } = token\n    if (type === 'footnote_start') {\n      isInFootnote = true\n      footnoteTokens.push(token)\n    } else if (type === 'footnote_end') {\n      isInFootnote = false\n      footnoteTokens.push(token)\n    } else if (isInFootnote) {\n      footnoteTokens.push(token)\n    } else {\n      hasNoFootnoteTokens.push(token)\n    }\n  }\n\n  const result = [...hasNoFootnoteTokens, ...footnoteTokens]\n  result.links = tokens.links\n  result.footnotes = tokens.footnotes\n  return result\n}\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function (src, top) {\n  const {\n    footnote,\n    frontMatter,\n    isGitlabCompatibilityEnabled,\n    math\n  } = this.options\n  src = src.replace(/^ +$/gm, '')\n\n  let loose\n  let cap\n  let bull\n  let b\n  let item\n  let space\n  let i\n  let tag\n  let l\n\n  // Only check front matter at the begining of a markdown file.\n  // Please see note in \"blockquote\" why we need \"checkFrontmatter\" and \"top\".\n  if (frontMatter) {\n    cap = this.rules.frontmatter.exec(src)\n    if (this.checkFrontmatter && top && cap) {\n      src = src.substring(cap[0].length)\n      let lang\n      let style\n      let text\n      if (cap[1]) {\n        lang = 'yaml'\n        style = '-'\n        text = cap[1]\n      } else if (cap[2]) {\n        lang = 'toml'\n        style = '+'\n        text = cap[2]\n      } else if (cap[3] || cap[4]) {\n        lang = 'json'\n        style = cap[3] ? ';' : '{'\n        text = cap[3] || cap[4]\n      }\n      this.tokens.push({\n        type: 'frontmatter',\n        text,\n        style,\n        lang\n      })\n    }\n    this.checkFrontmatter = false\n  }\n\n  while (src) {\n    // newline\n    cap = this.rules.newline.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        })\n      }\n    }\n\n    // code\n    // An indented code block cannot interrupt a paragraph.\n    cap = this.rules.code.exec(src)\n    if (cap) {\n      const lastToken = this.tokens[this.tokens.length - 1]\n      src = src.substring(cap[0].length)\n      if (lastToken && lastToken.type === 'paragraph') {\n        lastToken.text += `\\n${cap[0].trimRight()}`\n      } else {\n        cap = cap[0].replace(/^ {4}/gm, '')\n        this.tokens.push({\n          type: 'code',\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic\n            ? rtrim(cap, '\\n')\n            : cap\n        })\n      }\n      continue\n    }\n\n    // multiple line math\n    if (math) {\n      cap = this.rules.multiplemath.exec(src)\n      if (cap) {\n        src = src.substring(cap[0].length)\n        this.tokens.push({\n          type: 'multiplemath',\n          text: cap[1],\n          mathStyle: ''\n        })\n        continue\n      }\n\n      // match GitLab display math blocks (```math)\n      if (isGitlabCompatibilityEnabled) {\n        cap = this.rules.multiplemathGitlab.exec(src)\n        if (cap) {\n          src = src.substring(cap[0].length)\n          this.tokens.push({\n            type: 'multiplemath',\n            text: cap[2] || '',\n            mathStyle: 'gitlab'\n          })\n          continue\n        }\n      }\n    }\n\n    // footnote\n    if (footnote) {\n      cap = this.rules.footnote.exec(src)\n      if (top && cap) {\n        src = src.substring(cap[0].length)\n        const identifier = cap[1]\n        this.tokens.push({\n          type: 'footnote_start',\n          identifier\n        })\n\n        // NOTE: Order is wrong if footnote identifier 1 is behind footnote identifier 2 in text.\n        this.tokens.footnotes[identifier] = {\n          order: ++this.footnoteOrder,\n          identifier,\n          footnoteId: getUniqueId()\n        }\n\n        /* eslint-disable no-useless-escape */\n        // Remove the footnote identifer prefix. eg: `[^identifier]: `.\n        cap = cap[0].replace(/^\\[\\^[^\\^\\[\\]\\s]+?(?<!\\\\)\\]:\\s+/gm, '')\n        // Remove the four whitespace before each block of footnote.\n        cap = cap.replace(/\\n {4}(?=[^\\s])/g, '\\n')\n        /* eslint-enable no-useless-escape */\n\n        this.token(cap, top)\n\n        this.tokens.push({\n          type: 'footnote_end'\n        })\n\n        continue\n      }\n    }\n\n    // fences\n    cap = this.rules.fences.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n      const raw = cap[0]\n      const text = indentCodeCompensation(raw, cap[3] || '')\n      this.tokens.push({\n        type: 'code',\n        codeBlockStyle: 'fenced',\n        lang: cap[2] ? cap[2].trim() : cap[2],\n        text\n      })\n      continue\n    }\n\n    // heading\n    cap = this.rules.heading.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n      let text = cap[2] ? cap[2].trim() : ''\n\n      if (text.endsWith('#')) {\n        var trimmed = rtrim(text, '#')\n\n        if (this.options.pedantic) {\n          text = trimmed.trim()\n        } else if (!trimmed || trimmed.endsWith(' ')) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim()\n        }\n      }\n\n      this.tokens.push({\n        type: 'heading',\n        headingStyle: 'atx',\n        depth: cap[1].length,\n        text\n      })\n      continue\n    }\n\n    // table no leading pipe (gfm)\n    cap = this.rules.nptable.exec(src)\n    if (cap) {\n      item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n      }\n\n      if (item.header.length === item.align.length) {\n        src = src.substring(cap[0].length)\n\n        for (i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right'\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center'\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left'\n          } else {\n            item.align[i] = null\n          }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n          item.cells[i] = splitCells(item.cells[i], item.header.length)\n        }\n\n        this.tokens.push(item)\n\n        continue\n      }\n    }\n\n    // hr\n    cap = this.rules.hr.exec(src)\n    if (cap) {\n      const marker = cap[0].replace(/\\n*$/, '')\n      src = src.substring(cap[0].length)\n      this.tokens.push({\n        type: 'hr',\n        marker\n      })\n      continue\n    }\n\n    // blockquote\n    cap = this.rules.blockquote.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      })\n\n      cap = cap[0].replace(/^ *> ?/gm, '')\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top)\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      })\n\n      continue\n    }\n\n    // NOTE: Complete list lexer part is a custom implementation based on an older marked.js version.\n\n    // list\n    cap = this.rules.list.exec(src)\n    if (cap) {\n      let checked\n      src = src.substring(cap[0].length)\n      bull = cap[2]\n      let isOrdered = bull.length > 1\n      this.tokens.push({\n        type: 'list_start',\n        ordered: isOrdered,\n        listType: bull.length > 1 ? 'order' : (/^( {0,3})([-*+]) \\[[xX ]\\]/.test(cap[0]) ? 'task' : 'bullet'),\n        start: isOrdered ? +(bull.slice(0, -1)) : ''\n      })\n\n      let next = false\n      let prevNext = true\n      let listItemIndices = []\n      let isTaskList = false\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item)\n      l = cap.length\n      i = 0\n\n      for (; i < l; i++) {\n        const itemWithBullet = cap[i]\n        item = itemWithBullet\n        let newIsTaskListItem = false\n\n        // Remove the list item's bullet so it is seen as the next token.\n        space = item.length\n        let newBull\n        item = item.replace(/^ *([*+-]|\\d+(?:\\.|\\))) {0,4}/, function (m, p1) {\n          // Get and remove list item bullet\n          newBull = p1 || bull\n          return ''\n        })\n\n        const newIsOrdered = bull.length > 1 && /\\d{1,9}/.test(newBull)\n        if (!newIsOrdered && this.options.gfm) {\n          checked = this.rules.checkbox.exec(item)\n          if (checked) {\n            checked = checked[1] === 'x' || checked[1] === 'X'\n            newIsTaskListItem = true\n\n            // Remove the list item's checkbox and adjust indentation by removing checkbox length.\n            item = item.replace(this.rules.checkbox, '')\n            space -= 4\n          } else {\n            checked = undefined\n          }\n        }\n\n        if (i === 0) {\n          isTaskList = newIsTaskListItem\n        } else if (\n          // Changing the bullet or ordered list delimiter starts a new list (CommonMark 264 and 265)\n          //   - unordered, unordered --> bull !== newBull --> new list (e.g \"-\" --> \"*\")\n          //   - ordered, ordered --> lastChar !== lastChar --> new list (e.g \".\" --> \")\")\n          //   - else --> new list (e.g. ordered --> unordered)\n          i !== 0 &&\n          (\n            (!isOrdered && !newIsOrdered && bull !== newBull) ||\n            (isOrdered && newIsOrdered && bull.slice(-1) !== newBull.slice(-1)) ||\n            (isOrdered !== newIsOrdered) ||\n            // Changing to/from task list item from/to bullet, starts a new list(work for marktext issue #870)\n            // Because we distinguish between task list and bullet list in Mark Text,\n            // the parsing here is somewhat different from the commonmark Spec,\n            // and the task list needs to be a separate list.\n            (isTaskList !== newIsTaskListItem)\n          )\n        ) {\n          this.tokens.push({\n            type: 'list_end'\n          })\n\n          // Start a new list\n          bull = newBull\n          isOrdered = newIsOrdered\n          isTaskList = newIsTaskListItem\n          this.tokens.push({\n            type: 'list_start',\n            ordered: isOrdered,\n            listType: bull.length > 1 ? 'order' : (/^( {0,3})([-*+]) \\[[xX ]\\]/.test(itemWithBullet) ? 'task' : 'bullet'),\n            start: isOrdered ? +(bull.slice(0, -1)) : ''\n          })\n        }\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '')\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (i !== l - 1) {\n          b = this.rules.bullet.exec(cap[i + 1])[0]\n          if (bull.length > 1 ? b.length === 1\n            : (b.length > 1 || (this.options.smartLists && b !== bull))) {\n            src = cap.slice(i + 1).join('\\n') + src\n            i = l - 1\n          }\n        }\n\n        let prevItem = ''\n        if (i === 0) {\n          prevItem = item\n        } else {\n          prevItem = cap[i - 1]\n        }\n\n        // Determine whether item is loose or not. If previous item is loose\n        // this item is also loose.\n        // A list is loose if any of its constituent list items are separated by blank lines,\n        // or if any of its constituent list items directly contain two block-level elements with a blank line between them.\n        // loose = next = next || /^ *([*+-]|\\d{1,9}(?:\\.|\\)))( +\\S+\\n\\n(?!\\s*$)|\\n\\n(?!\\s*$))/.test(itemWithBullet)\n        loose = next = next || /\\n\\n(?!\\s*$)/.test(item)\n        // Check if previous line ends with a new line.\n        if (!loose && (i !== 0 || l > 1) && prevItem.length !== 0 && prevItem.charAt(prevItem.length - 1) === '\\n') {\n          loose = next = true\n        }\n\n        // A list is either loose or tight, so update previous list items but not nested list items.\n        if (next && prevNext !== next) {\n          for (const index of listItemIndices) {\n            this.tokens[index].type = 'loose_item_start'\n          }\n          listItemIndices = []\n        }\n        prevNext = next\n\n        if (!loose) {\n          listItemIndices.push(this.tokens.length)\n        }\n\n        const isOrderedListItem = /\\d/.test(bull)\n        this.tokens.push({\n          checked,\n          listItemType: bull.length > 1 ? 'order' : (isTaskList ? 'task' : 'bullet'),\n          bulletMarkerOrDelimiter: isOrderedListItem ? bull.slice(-1) : bull.charAt(0),\n          type: loose ? 'loose_item_start' : 'list_item_start'\n        })\n\n        if (/^\\s*$/.test(item)) {\n          this.tokens.push({\n            type: 'text',\n            text: ''\n          })\n        } else {\n          // Recurse.\n          this.token(item, false)\n        }\n\n        this.tokens.push({\n          type: 'list_item_end'\n        })\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      })\n      continue\n    }\n\n    // html\n    cap = this.rules.html.exec(src)\n    if (cap) {\n      src = src.substring(cap[0].length)\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: !this.options.sanitizer &&\n          (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]\n      })\n      continue\n    }\n\n    // def\n    cap = this.rules.def.exec(src)\n    if (top && cap) {\n      let text = ''\n      do {\n        src = src.substring(cap[0].length)\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1)\n        tag = cap[1].toLowerCase().replace(/\\s+/g, ' ')\n        if (!this.tokens.links[tag]) {\n          this.tokens.links[tag] = {\n            href: cap[2],\n            title: cap[3]\n          }\n        }\n\n        text += cap[0]\n        if (cap[0].endsWith('\\n\\n')) break\n        cap = this.rules.def.exec(src)\n      } while (cap)\n\n      if (this.options.disableInline) {\n        this.tokens.push({\n          type: 'paragraph',\n          text: text.replace(/\\n*$/, '')\n        })\n      }\n      continue\n    }\n\n    // table (gfm)\n    cap = this.rules.table.exec(src)\n    if (cap) {\n      item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n      }\n\n      if (item.header.length === item.align.length) {\n        src = src.substring(cap[0].length)\n\n        for (i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right'\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center'\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left'\n          } else {\n            item.align[i] = null\n          }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n          item.cells[i] = splitCells(\n            item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n            item.header.length)\n        }\n\n        this.tokens.push(item)\n\n        continue\n      }\n    }\n\n    // lheading\n    cap = this.rules.lheading.exec(src)\n    if (cap) {\n      const precededToken = this.tokens[this.tokens.length - 1]\n      const chops = cap[0].trim().split(/\\n/)\n      const marker = chops[chops.length - 1]\n      src = src.substring(cap[0].length)\n\n      if (precededToken && precededToken.type === 'paragraph') {\n        this.tokens.pop()\n        this.tokens.push({\n          type: 'heading',\n          headingStyle: 'setext',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: precededToken.text + '\\n' + cap[1],\n          marker\n        })\n      } else {\n        this.tokens.push({\n          type: 'heading',\n          headingStyle: 'setext',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1],\n          marker\n        })\n      }\n      continue\n    }\n\n    // top-level paragraph\n    cap = this.rules.paragraph.exec(src)\n    if (top && cap) {\n      src = src.substring(cap[0].length)\n\n      if (/^\\[toc\\]\\n?$/i.test(cap[1])) {\n        this.tokens.push({ type: 'toc', text: '[TOC]' })\n        continue\n      }\n\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      })\n      continue\n    }\n\n    // text\n    cap = this.rules.text.exec(src)\n    if (cap) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length)\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      })\n      continue\n    }\n\n    if (src) {\n      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0))\n    }\n  }\n}\n\nfunction indentCodeCompensation (raw, text) {\n  const matchIndentToCode = raw.match(/^(\\s+)(?:```)/)\n\n  if (matchIndentToCode === null) {\n    return text\n  }\n\n  const indentToCode = matchIndentToCode[1]\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(/^\\s+/)\n      if (matchIndentInNode === null) {\n        return node\n      }\n\n      const [indentInNode] = matchIndentInNode\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length)\n      }\n\n      return node\n    })\n    .join('\\n')\n}\n\nexport default Lexer\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\prism\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\snabbdom.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\utils.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\utils.js",["584"],"/**\n * Helpers\n */\n\nlet uniqueIdCounter = 0\n\nexport const getUniqueId = () => ++uniqueIdCounter\n\nexport const escape = function escape (html, encode) {\n  if (encode) {\n    if (escape.escapeTest.test(html)) {\n      return html.replace(escape.escapeReplace, function (ch) { return escape.replacements[ch] })\n    }\n  } else {\n    if (escape.escapeTestNoEncode.test(html)) {\n      return html.replace(escape.escapeReplaceNoEncode, function (ch) { return escape.replacements[ch] })\n    }\n  }\n\n  return html\n}\n\nescape.escapeTest = /[&<>\"']/\nescape.escapeReplace = /[&<>\"']/g\nescape.replacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n}\n\nescape.escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/\nescape.escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g\n\nexport const unescape = function unescape (html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig, function (_, n) {\n    n = n.toLowerCase()\n    if (n === 'colon') return ':'\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1))\n    }\n    return ''\n  })\n}\n\nexport const edit = function edit (regex, opt) {\n  regex = regex.source || regex\n  opt = opt || ''\n  return {\n    replace: function (name, val) {\n      val = val.source || val\n      val = val.replace(/(^|[^\\[])\\^/g, '$1') // eslint-disable-line no-useless-escape\n      regex = regex.replace(name, val)\n      return this\n    },\n    getRegex: function () {\n      return new RegExp(regex, opt)\n    }\n  }\n}\n\nexport const cleanUrl = function cleanUrl (sanitize, base, href) {\n  if (sanitize) {\n    let prot = ''\n    try {\n      prot = decodeURIComponent(unescape(href))\n        .replace(/[^\\w:]/g, '')\n        .toLowerCase()\n    } catch (e) {\n      return null\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href)\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%')\n  } catch (e) {\n    return null\n  }\n  return href\n}\n\nconst resolveUrl = function resolveUrl (base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (/^[^:]+:\\/*[^/]*$/.test(base)) {\n      baseUrls[' ' + base] = base + '/'\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true)\n    }\n  }\n  base = baseUrls[' ' + base]\n  let relativeBase = base.indexOf(':') === -1\n\n  if (href.slice(0, 2) === '//') {\n    if (relativeBase) {\n      return href\n    }\n    return base.replace(/^([^:]+:)[\\s\\S]*$/, '$1') + href\n  } else if (href.charAt(0) === '/') {\n    if (relativeBase) {\n      return href\n    }\n    return base.replace(/^([^:]+:\\/*[^/]*)[\\s\\S]*$/, '$1') + href\n  } else {\n    return base + href\n  }\n}\nconst baseUrls = {}\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i\n\nexport const noop = function noop () {}\nnoop.exec = noop\n\nexport const splitCells = function splitCells (tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(/\\|/g, function (match, offset, str) {\n    let escaped = false\n    let curr = offset\n    while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped\n    if (escaped) {\n      // odd number of slashes means | is escaped\n      // so we leave it alone\n      return '|'\n    } else {\n      // add space before unescaped |\n      return ' |'\n    }\n  })\n  const cells = row.split(/ \\|/)\n  let i = 0\n\n  if (cells.length > count) {\n    cells.splice(count)\n  } else {\n    while (cells.length < count) cells.push('')\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|')\n  }\n  return cells\n}\n\n// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n// /c*$/ is vulnerable to REDOS.\n// invert: Remove suffix of non-c chars instead. Default falsey.\nexport const rtrim = function rtrim (str, c, invert) {\n  if (str.length === 0) {\n    return ''\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < str.length) {\n    const currChar = str.charAt(str.length - suffLen - 1)\n    if (currChar === c && !invert) {\n      suffLen++\n    } else if (currChar !== c && invert) {\n      suffLen++\n    } else {\n      break\n    }\n  }\n\n  return str.substr(0, str.length - suffLen)\n}\n\nexport const findClosingBracket = function findClosingBracket (str, b) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1\n  }\n  let level = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\\\') {\n      i++\n    } else if (str[i] === b[0]) {\n      level++\n    } else if (str[i] === b[1]) {\n      level--\n      if (level < 0) {\n        return i\n      }\n    }\n  }\n  return -1\n}\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\slugger.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\inlineLexer.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\textRenderer.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\prism\\loadLanguage.js",["585","586"],"import languages from './languages'\nlet peerDependentsMap = null\nexport const loadedCache = new Set(['markup', 'css', 'clike', 'javascript'])\nconst prismComponentCache = new Map()\n\nfunction getPeerDependentsMap () {\n  const peerDependentsMap = {}\n  Object.keys(languages).forEach(function (language) {\n    if (language === 'meta') {\n      return false\n    }\n    if (languages[language].peerDependencies) {\n      let peerDependencies = languages[language].peerDependencies\n      if (!Array.isArray(peerDependencies)) {\n        peerDependencies = [peerDependencies]\n      }\n      peerDependencies.forEach(function (peerDependency) {\n        if (!peerDependentsMap[peerDependency]) {\n          peerDependentsMap[peerDependency] = []\n        }\n        peerDependentsMap[peerDependency].push(language)\n      })\n    }\n  })\n  return peerDependentsMap\n}\n\nfunction getPeerDependents (mainLanguage) {\n  if (!peerDependentsMap) {\n    peerDependentsMap = getPeerDependentsMap()\n  }\n  return peerDependentsMap[mainLanguage] || []\n}\n\n// Look for the origin languge by alias\nexport const transfromAliasToOrigin = arr => {\n  const result = []\n  for (const lang of arr) {\n    if (languages[lang]) {\n      result.push(lang)\n    } else {\n      const language = Object.keys(languages).find(name => {\n        const l = languages[name]\n        if (l.alias) {\n          return l.alias === lang || Array.isArray(l.alias) && l.alias.includes(lang)\n        }\n        return false\n      })\n\n      if (language) {\n        result.push(language)\n      } else {\n        // The lang is not exist, the will handle in `initLoadLanguage`\n        result.push(lang)\n      }\n    }\n  }\n  return result\n}\n\nfunction initLoadLanguage (Prism) {\n  return async function loadLanguages (arr, withoutDependencies) {\n    // If no argument is passed, load all components\n    if (!arr) {\n      arr = Object.keys(languages).filter(function (language) {\n        return language !== 'meta'\n      })\n    }\n    if (arr && !arr.length) {\n      return Promise.reject(new Error('The first parameter should be a list of load languages or single language.'))\n    }\n\n    if (!Array.isArray(arr)) {\n      arr = [arr]\n    }\n\n    const promises = []\n    const transformedLangs = transfromAliasToOrigin(arr)\n    for (const language of transformedLangs) {\n      // handle not existed\n      if (!languages[language]) {\n        promises.push(Promise.resolve({\n          lang: language,\n          status: 'noexist'\n        }))\n        continue\n      }\n      // handle already cached\n      if (loadedCache.has(language)) {\n        promises.push(Promise.resolve({\n          lang: language,\n          status: 'cached'\n        }))\n        continue\n      }\n\n      // Load dependencies first\n      if (!withoutDependencies && languages[language].require) {\n        const results = await loadLanguages(languages[language].require)\n        promises.push(...results)\n      }\n\n      delete Prism.languages[language]\n      if (!prismComponentCache.has(language)) {\n        await import('prismjs/components/prism-' + language)\n        prismComponentCache.set(language, Prism.languages[language])\n      } else {\n        Prism.languages[language] = prismComponentCache.get(language)\n      }\n      loadedCache.add(language)\n      promises.push(Promise.resolve({\n        status: 'loaded',\n        lang: language\n      }))\n\n      // Reload dependents\n      const dependents = getPeerDependents(language).filter(function (dependent) {\n        // If dependent language was already loaded,\n        // we want to reload it.\n        if (Prism.languages[dependent]) {\n          delete Prism.languages[dependent]\n          loadedCache.delete(dependent)\n          return true\n        }\n        return false\n      })\n      if (dependents.length) {\n        const results = await loadLanguages(dependents, true)\n        promises.push(...results)\n      }\n    }\n\n    return Promise.all(promises)\n  }\n}\n\nexport default initLoadLanguage\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\blockRules.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\index.js",["587"],"import backlashInToken from './backlashInToken'\nimport backlash from './backlash'\nimport highlight from './highlight'\nimport header from './header'\nimport link from './link'\nimport htmlTag from './htmlTag'\nimport hr from './hr'\nimport tailHeader from './tailHeader'\nimport hardLineBreak from './hardLineBreak'\nimport softLineBreak from './softLineBreak'\nimport codeFense from './codeFense'\nimport inlineMath from './inlineMath'\nimport autoLink from './autoLink'\nimport autoLinkExtension from './autoLinkExtension'\nimport loadImageAsync from './loadImageAsync'\nimport image from './image'\nimport delEmStrongFac from './delEmStringFactory'\nimport emoji from './emoji'\nimport inlineCode from './inlineCode'\nimport text from './text'\nimport del from './del'\nimport em from './em'\nimport strong from './strong'\nimport htmlEscape from './htmlEscape'\nimport multipleMath from './multipleMath'\nimport referenceDefinition from './referenceDefinition'\nimport htmlRuby from './htmlRuby'\nimport referenceLink from './referenceLink'\nimport referenceImage from './referenceImage'\nimport superSubScript from './superSubScript'\nimport footnoteIdentifier from './footnoteIdentifier'\n\nexport default {\n  backlashInToken,\n  backlash,\n  highlight,\n  header,\n  link,\n  htmlTag,\n  hr,\n  tailHeader,\n  hardLineBreak,\n  softLineBreak,\n  codeFense,\n  inlineMath,\n  autoLink,\n  autoLinkExtension,\n  loadImageAsync,\n  image,\n  delEmStrongFac,\n  emoji,\n  inlineCode,\n  text,\n  del,\n  em,\n  strong,\n  htmlEscape,\n  multipleMath,\n  referenceDefinition,\n  htmlRuby,\n  referenceLink,\n  referenceImage,\n  superSubScript,\n  footnoteIdentifier\n}\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\index.js",["588"],"import renderBlock from './renderBlock'\nimport renderLeafBlock from './renderLeafBlock'\nimport renderContainerBlock from './renderContainerBlock'\nimport renderIcon from './renderIcon'\n\nexport default {\n  renderBlock,\n  renderLeafBlock,\n  renderContainerBlock,\n  renderIcon\n}\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\urlify.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\marked\\inlineRules.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderContainerBlock.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderBlock.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderIcon.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\footnoteIdentifier.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderLeafBlock.js",["589"],"import katex from 'katex'\nimport prism, { loadedCache, transfromAliasToOrigin } from '../../../prism/'\nimport { CLASS_OR_ID, DEVICE_MEMORY, PREVIEW_DOMPURIFY_CONFIG, HAS_TEXT_BLOCK_REG } from '../../../config'\nimport { tokenizer } from '../../'\nimport { snakeToCamel, sanitize, escapeHtml, getLongUniqueId, getImageInfo } from '../../../utils'\nimport { h, htmlToVNode } from '../snabbdom'\n\n// todo@jocs any better solutions?\nconst MARKER_HASK = {\n  '<': `%${getLongUniqueId()}%`,\n  '>': `%${getLongUniqueId()}%`,\n  '\"': `%${getLongUniqueId()}%`,\n  \"'\": `%${getLongUniqueId()}%`\n}\n\nconst getHighlightHtml = (text, highlights, escape = false, handleLineEnding = false) => {\n  let code = ''\n  let pos = 0\n  const getEscapeHTML = (className, content) => {\n    return `${MARKER_HASK['<']}span class=${MARKER_HASK['\"']}${className}${MARKER_HASK['\"']}${MARKER_HASK['>']}${content}${MARKER_HASK['<']}/span${MARKER_HASK['>']}`\n  }\n\n  for (const highlight of highlights) {\n    const { start, end, active } = highlight\n    code += text.substring(pos, start)\n    const className = active ? 'ag-highlight' : 'ag-selection'\n    let highlightContent = text.substring(start, end)\n    if (handleLineEnding && text.endsWith('\\n') && end === text.length) {\n      highlightContent = highlightContent.substring(start, end - 1) +\n      (escape\n        ? getEscapeHTML('ag-line-end', '\\n')\n        : '<span class=\"ag-line-end\">\\n</span>')\n    }\n    code += escape\n      ? getEscapeHTML(className, highlightContent)\n      : `<span class=\"${className}\">${highlightContent}</span>`\n    pos = end\n  }\n  if (pos !== text.length) {\n    if (handleLineEnding && text.endsWith('\\n')) {\n      code += text.substring(pos, text.length - 1) +\n      (escape\n        ? getEscapeHTML('ag-line-end', '\\n')\n        : '<span class=\"ag-line-end\">\\n</span>')\n    } else {\n      code += text.substring(pos)\n    }\n  }\n\n  return code\n}\n\nconst hasReferenceToken = tokens => {\n  let result = false\n  const travel = tokens => {\n    for (const token of tokens) {\n      if (/reference_image|reference_link/.test(token.type)) {\n        result = true\n        break\n      }\n      if (Array.isArray(token.children) && token.children.length) {\n        travel(token.children)\n      }\n    }\n  }\n  travel(tokens)\n  return result\n}\n\nexport default function renderLeafBlock (parent, block, activeBlocks, matches, useCache = false) {\n  const { loadMathMap } = this\n  const { cursor } = this.muya.contentState\n  let selector = this.getSelector(block, activeBlocks)\n  // highlight search key in block\n  const highlights = matches.filter(m => m.key === block.key)\n  const {\n    text,\n    type,\n    checked,\n    key,\n    lang,\n    functionType,\n    editable\n  } = block\n\n  const data = {\n    props: {},\n    attrs: {},\n    dataset: {},\n    style: {}\n  }\n\n  let children = ''\n\n  if (text) {\n    let tokens = []\n    if (highlights.length === 0 && this.tokenCache.has(text)) {\n      tokens = this.tokenCache.get(text)\n    } else if (\n      HAS_TEXT_BLOCK_REG.test(type) &&\n      functionType !== 'codeContent' &&\n      functionType !== 'languageInput'\n    ) {\n      const hasBeginRules = /paragraphContent|atxLine/.test(functionType)\n\n      tokens = tokenizer(text, {\n        highlights,\n        hasBeginRules,\n        labels: this.labels,\n        options: this.muya.options\n      })\n      const hasReferenceTokens = hasReferenceToken(tokens)\n      if (highlights.length === 0 && useCache && DEVICE_MEMORY >= 4 && !hasReferenceTokens) {\n        this.tokenCache.set(text, tokens)\n      }\n    }\n\n    children = tokens.reduce((acc, token) => [...acc, ...this[snakeToCamel(token.type)](h, cursor, block, token)], [])\n  }\n\n  if (editable === false) {\n    Object.assign(data.attrs, {\n      spellcheck: 'false',\n      contenteditable: 'false'\n    })\n  }\n\n  if (type === 'div') {\n    const code = this.codeCache.get(block.preSibling)\n    switch (functionType) {\n      case 'html': {\n        selector += `.${CLASS_OR_ID.AG_HTML_PREVIEW}`\n        Object.assign(data.attrs, { spellcheck: 'false' })\n\n        const { disableHtml } = this.muya.options\n        const htmlContent = sanitize(code, PREVIEW_DOMPURIFY_CONFIG, disableHtml)\n\n        // handle empty html bock\n        if (/^<([a-z][a-z\\d]*)[^>]*?>(\\s*)<\\/\\1>$/.test(htmlContent.trim())) {\n          children = htmlToVNode('<div class=\"ag-empty\">&lt;Empty HTML Block&gt;</div>')\n        } else {\n          const parser = new DOMParser()\n          const doc = parser.parseFromString(htmlContent, 'text/html')\n          const imgs = doc.documentElement.querySelectorAll('img')\n          for (const img of imgs) {\n            const src = img.getAttribute('src')\n            const imageInfo = getImageInfo(src)\n            img.setAttribute('src', imageInfo.src)\n          }\n\n          children = htmlToVNode(doc.documentElement.querySelector('body').innerHTML)\n        }\n        break\n      }\n      case 'multiplemath': {\n        const key = `${code}_display_math`\n        selector += `.${CLASS_OR_ID.AG_CONTAINER_PREVIEW}`\n        Object.assign(data.attrs, { spellcheck: 'false' })\n        if (code === '') {\n          children = '< Empty Mathematical Formula >'\n          selector += `.${CLASS_OR_ID.AG_EMPTY}`\n        } else if (loadMathMap.has(key)) {\n          children = loadMathMap.get(key)\n        } else {\n          try {\n            const html = katex.renderToString(code, {\n              displayMode: true\n            })\n\n            children = htmlToVNode(html)\n            loadMathMap.set(key, children)\n          } catch (err) {\n            children = '< Invalid Mathematical Formula >'\n            selector += `.${CLASS_OR_ID.AG_MATH_ERROR}`\n          }\n        }\n        break\n      }\n      case 'mermaid': {\n        selector += `.${CLASS_OR_ID.AG_CONTAINER_PREVIEW}`\n        Object.assign(data.attrs, { spellcheck: 'false' })\n        if (code === '') {\n          children = '< Empty Mermaid Block >'\n          selector += `.${CLASS_OR_ID.AG_EMPTY}`\n        } else {\n          children = 'Loading...'\n          this.mermaidCache.set(`#${block.key}`, {\n            code,\n            functionType\n          })\n        }\n        break\n      }\n      case 'flowchart':\n      case 'sequence':\n      case 'vega-lite': {\n        selector += `.${CLASS_OR_ID.AG_CONTAINER_PREVIEW}`\n        Object.assign(data.attrs, { spellcheck: 'false' })\n        if (code === '') {\n          children = '< Empty Diagram Block >'\n          selector += `.${CLASS_OR_ID.AG_EMPTY}`\n        } else {\n          children = 'Loading...'\n          this.diagramCache.set(`#${block.key}`, {\n            code,\n            functionType\n          })\n        }\n        break\n      }\n    }\n  } else if (type === 'input') {\n    const { fontSize, lineHeight } = this.muya.options\n\n    Object.assign(data.attrs, {\n      type: 'checkbox',\n      style: `top: ${(fontSize * lineHeight / 2 - 8).toFixed(2)}px`\n    })\n\n    selector = `${type}#${key}.${CLASS_OR_ID.AG_TASK_LIST_ITEM_CHECKBOX}`\n    if (checked) {\n      Object.assign(data.attrs, {\n        checked: true\n      })\n      selector += `.${CLASS_OR_ID.AG_CHECKBOX_CHECKED}`\n    }\n    children = ''\n  } else if (type === 'span' && functionType === 'codeContent') {\n    const code = escapeHtml(getHighlightHtml(text, highlights, true, true))\n      .replace(new RegExp(MARKER_HASK['<'], 'g'), '<')\n      .replace(new RegExp(MARKER_HASK['>'], 'g'), '>')\n      .replace(new RegExp(MARKER_HASK['\"'], 'g'), '\"')\n      .replace(new RegExp(MARKER_HASK[\"'\"], 'g'), \"'\")\n    // transfrom alias to original language\n    const transformedLang = transfromAliasToOrigin([lang])[0]\n\n    if (transformedLang && /\\S/.test(code) && loadedCache.has(transformedLang)) {\n      const wrapper = document.createElement('div')\n      wrapper.classList.add(`language-${transformedLang}`)\n      wrapper.innerHTML = code\n      prism.highlightElement(wrapper, false, function () {\n        const highlightedCode = this.innerHTML\n        selector += `.language-${transformedLang}`\n        children = htmlToVNode(highlightedCode)\n      })\n    } else {\n      children = htmlToVNode(code)\n    }\n  } else if (type === 'span' && functionType === 'languageInput') {\n    const html = getHighlightHtml(text, highlights)\n    children = htmlToVNode(html)\n  } else if (type === 'span' && functionType === 'footnoteInput') {\n    Object.assign(data.attrs, { spellcheck: 'false' })\n  }\n\n  if (!block.parent) {\n    return h(selector, data, [this.renderIcon(block), ...children])\n  } else {\n    return h(selector, data, children)\n  }\n}\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\superSubScript.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\referenceImage.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\referenceLink.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\multipleMath.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\referenceDefinition.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\strong.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\em.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\htmlEscape.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\htmlRuby.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\del.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\emoji.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\text.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\delEmStringFactory.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\inlineCode.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\image.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\loadImageAsync.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\autoLinkExtension.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\autoLink.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\codeFense.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\softLineBreak.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\hr.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\tailHeader.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\inlineMath.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\hardLineBreak.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\link.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\htmlTag.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\header.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\highlight.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\backlash.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderInlines\\backlashInToken.js",["590"],"import { union, isEven } from '../../../utils'\nimport { CLASS_OR_ID } from '../../../config'\n// TODO HIGHLIGHT\nexport default function backlashInToken (h, backlashes, outerClass, start, token) {\n  const { highlights = [] } = token\n  const chunks = backlashes.split('')\n  const len = chunks.length\n  const result = []\n  let i\n\n  for (i = 0; i < len; i++) {\n    const chunk = chunks[i]\n    const light = highlights.filter(light => union({ start: start + i, end: start + i + 1 }, light))\n    let selector = 'span'\n    if (light.length) {\n      const className = this.getHighlightClassName(light[0].active)\n      selector += `.${className}`\n    }\n    if (isEven(i)) {\n      result.push(\n        h(`${selector}.${outerClass}`, chunk)\n      )\n    } else {\n      result.push(\n        h(`${selector}.${CLASS_OR_ID.AG_BACKLASH}`, chunk)\n      )\n    }\n  }\n\n  return result\n}\n","C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderCopyButton.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderTableDargBar.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderContainerEditIcon.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderToolBar.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\parser\\render\\renderBlock\\renderFootnoteJump.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\quickInsert\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\quickInsert\\config.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\baseScrollFloat\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\baseFloat\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\muya\\lib\\ui\\tablePicker\\index.js",[],"C:\\Users\\Kyle\\Desktop\\Current\\mnotes\\src\\Editor.js",[],{"ruleId":"591","replacedBy":"592"},{"ruleId":"593","replacedBy":"594"},{"ruleId":"595","severity":1,"message":"596","line":69,"column":11,"nodeType":"597","messageId":"598","endLine":94,"endColumn":12},{"ruleId":"595","severity":1,"message":"596","line":203,"column":5,"nodeType":"597","messageId":"598","endLine":221,"endColumn":6},{"ruleId":"595","severity":1,"message":"596","line":100,"column":7,"nodeType":"597","messageId":"598","endLine":126,"endColumn":8},{"ruleId":"599","severity":1,"message":"600","line":154,"column":28,"nodeType":"601","messageId":"602","endLine":154,"endColumn":30},{"ruleId":"599","severity":1,"message":"600","line":154,"column":69,"nodeType":"601","messageId":"602","endLine":154,"endColumn":71},{"ruleId":"599","severity":1,"message":"603","line":154,"column":69,"nodeType":"601","messageId":"602","endLine":154,"endColumn":71},{"ruleId":"599","severity":1,"message":"603","line":155,"column":59,"nodeType":"601","messageId":"602","endLine":155,"endColumn":61},{"ruleId":"599","severity":1,"message":"600","line":217,"column":31,"nodeType":"601","messageId":"602","endLine":217,"endColumn":33},{"ruleId":"599","severity":1,"message":"600","line":217,"column":60,"nodeType":"601","messageId":"602","endLine":217,"endColumn":62},{"ruleId":"595","severity":1,"message":"596","line":388,"column":9,"nodeType":"597","messageId":"598","endLine":402,"endColumn":10},{"ruleId":"595","severity":1,"message":"596","line":450,"column":7,"nodeType":"597","messageId":"598","endLine":496,"endColumn":8},{"ruleId":"604","severity":1,"message":"605","line":316,"column":38,"nodeType":"606","messageId":"607","endLine":318,"endColumn":14},{"ruleId":"604","severity":1,"message":"605","line":328,"column":38,"nodeType":"606","messageId":"607","endLine":330,"endColumn":14},{"ruleId":"595","severity":1,"message":"596","line":196,"column":7,"nodeType":"597","messageId":"598","endLine":211,"endColumn":8},{"ruleId":"595","severity":1,"message":"596","line":277,"column":5,"nodeType":"597","messageId":"598","endLine":317,"endColumn":6},{"ruleId":"595","severity":1,"message":"596","line":68,"column":7,"nodeType":"597","messageId":"598","endLine":85,"endColumn":8},{"ruleId":"595","severity":1,"message":"596","line":121,"column":5,"nodeType":"597","messageId":"598","endLine":235,"endColumn":6},{"ruleId":"604","severity":1,"message":"605","line":175,"column":32,"nodeType":"606","messageId":"607","endLine":186,"endColumn":16},{"ruleId":"595","severity":1,"message":"596","line":479,"column":5,"nodeType":"597","messageId":"598","endLine":633,"endColumn":6},{"ruleId":"599","severity":1,"message":"603","line":660,"column":17,"nodeType":"601","messageId":"602","endLine":660,"endColumn":19},{"ruleId":"599","severity":1,"message":"603","line":660,"column":68,"nodeType":"601","messageId":"602","endLine":660,"endColumn":70},{"ruleId":"595","severity":1,"message":"596","line":928,"column":5,"nodeType":"597","messageId":"598","endLine":1031,"endColumn":6},{"ruleId":"595","severity":1,"message":"596","line":379,"column":7,"nodeType":"597","messageId":"598","endLine":406,"endColumn":8},{"ruleId":"595","severity":1,"message":"596","line":9,"column":3,"nodeType":"597","messageId":"598","endLine":48,"endColumn":4},{"ruleId":"595","severity":1,"message":"596","line":60,"column":3,"nodeType":"597","messageId":"598","endLine":85,"endColumn":4},{"ruleId":"595","severity":1,"message":"596","line":95,"column":3,"nodeType":"597","messageId":"598","endLine":136,"endColumn":4},{"ruleId":"599","severity":1,"message":"603","line":222,"column":30,"nodeType":"601","messageId":"602","endLine":222,"endColumn":32},{"ruleId":"599","severity":1,"message":"603","line":223,"column":29,"nodeType":"601","messageId":"602","endLine":223,"endColumn":31},{"ruleId":"599","severity":1,"message":"603","line":246,"column":37,"nodeType":"601","messageId":"602","endLine":246,"endColumn":39},{"ruleId":"599","severity":1,"message":"603","line":247,"column":38,"nodeType":"601","messageId":"602","endLine":247,"endColumn":40},{"ruleId":"599","severity":1,"message":"603","line":250,"column":37,"nodeType":"601","messageId":"602","endLine":250,"endColumn":39},{"ruleId":"599","severity":1,"message":"603","line":251,"column":36,"nodeType":"601","messageId":"602","endLine":251,"endColumn":38},{"ruleId":"599","severity":1,"message":"603","line":345,"column":33,"nodeType":"601","messageId":"602","endLine":345,"endColumn":35},{"ruleId":"599","severity":1,"message":"603","line":345,"column":78,"nodeType":"601","messageId":"602","endLine":345,"endColumn":80},{"ruleId":"595","severity":1,"message":"596","line":359,"column":9,"nodeType":"597","messageId":"598","endLine":377,"endColumn":10},{"ruleId":"599","severity":1,"message":"603","line":199,"column":66,"nodeType":"601","messageId":"602","endLine":199,"endColumn":68},{"ruleId":"599","severity":1,"message":"603","line":200,"column":70,"nodeType":"601","messageId":"602","endLine":200,"endColumn":72},{"ruleId":"595","severity":1,"message":"596","line":107,"column":7,"nodeType":"597","messageId":"598","endLine":138,"endColumn":8},{"ruleId":"595","severity":1,"message":"596","line":10,"column":5,"nodeType":"597","messageId":"598","endLine":24,"endColumn":6},{"ruleId":"599","severity":1,"message":"603","line":606,"column":46,"nodeType":"601","messageId":"602","endLine":606,"endColumn":48},{"ruleId":"599","severity":1,"message":"603","line":606,"column":69,"nodeType":"601","messageId":"602","endLine":606,"endColumn":71},{"ruleId":"595","severity":1,"message":"596","line":284,"column":5,"nodeType":"597","messageId":"598","endLine":305,"endColumn":6},{"ruleId":"599","severity":1,"message":"603","line":485,"column":35,"nodeType":"601","messageId":"602","endLine":485,"endColumn":37},{"ruleId":"599","severity":1,"message":"603","line":485,"column":64,"nodeType":"601","messageId":"602","endLine":485,"endColumn":66},{"ruleId":"608","severity":1,"message":"609","line":8,"column":9,"nodeType":"610","messageId":"611","endLine":8,"endColumn":10},{"ruleId":"591","replacedBy":"612"},{"ruleId":"593","replacedBy":"613"},{"ruleId":"614","severity":1,"message":"615","line":1,"column":1,"nodeType":"616","endLine":37,"endColumn":2},{"ruleId":"604","severity":1,"message":"617","line":358,"column":62,"nodeType":"618","messageId":"607","endLine":362,"endColumn":10},{"ruleId":"619","severity":1,"message":"620","line":76,"column":22,"nodeType":"621","messageId":"622","endLine":76,"endColumn":35},{"ruleId":"599","severity":1,"message":"603","line":45,"column":35,"nodeType":"601","messageId":"602","endLine":45,"endColumn":37},{"ruleId":"599","severity":1,"message":"603","line":45,"column":61,"nodeType":"601","messageId":"602","endLine":45,"endColumn":63},{"ruleId":"614","severity":1,"message":"615","line":33,"column":1,"nodeType":"616","endLine":65,"endColumn":2},{"ruleId":"614","severity":1,"message":"615","line":6,"column":1,"nodeType":"616","endLine":11,"endColumn":2},{"ruleId":"595","severity":1,"message":"596","line":130,"column":5,"nodeType":"597","messageId":"598","endLine":211,"endColumn":6},{"ruleId":"604","severity":1,"message":"623","line":13,"column":37,"nodeType":"606","messageId":"607","endLine":13,"endColumn":100},"no-native-reassign",["624"],"no-negated-in-lhs",["625"],"default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-mixed-operators","Unexpected mix of '&&' and '||'.","LogicalExpression","unexpectedMixedOperator","Unexpected mix of '||' and '&&'.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'i'.","ArrowFunctionExpression","unsafeRefs","no-unused-vars","'m' is defined but never used.","Identifier","unusedVar",["624"],["625"],"import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration","Function declared in a loop contains unsafe references to variable(s) 'bull'.","FunctionExpression","no-script-url","Script URL is a form of eval.","Literal","unexpectedScriptURL","Function declared in a loop contains unsafe references to variable(s) 'i', 'i'.","no-global-assign","no-unsafe-negation"]